<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scrilla.analysis.estimators API documentation</title>
<meta name="description" content="A module of statistical point estimators and likelihood functions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrilla.analysis.estimators</code></h1>
</header>
<section id="section-intro">
<p>A module of statistical point estimators and likelihood functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of scrilla: https://github.com/chinchalinchin/scrilla.

# scrilla is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.

# scrilla is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with scrilla.  If not, see &lt;https://www.gnu.org/licenses/&gt;
# or &lt;https://github.com/chinchalinchin/scrilla/blob/develop/main/LICENSE&gt;.

&#34;&#34;&#34;
A module of statistical point estimators and likelihood functions.
&#34;&#34;&#34;

from os import path
from sys import path as sys_path
from typing import List, Union
from numpy import inf
from math import log, sqrt, exp
from scipy.stats import norm, multivariate_normal

if __name__ == &#34;__main__&#34;:
    APP_DIR = path.dirname(path.dirname(path.abspath(__file__)))
    sys_path.append(APP_DIR)

from scrilla import settings, errors, cache
from scrilla.static.constants import constants
import scrilla.util.outputter as outputter

logger = outputter.Logger(&#39;scrilla.analysis.estimators&#39;, settings.LOG_LEVEL)
profile_cache = cache.ProfileCache()
correlation_cache = cache.CorrelationCache()


def univariate_normal_likelihood_function(params: list, data: list) -&gt; float:
    &#34;&#34;&#34;
    This function returns the likelihood of a vector of parameters being observed from a sample univariate data of normal data. It can be used as objective function input for `scipy.optimize`&#39;s optimization methods. 

    Parameters
    ----------
    1. **x** : ``list``
        Array representing a vector of parameters , in this case the mean rate of return and volatility from a sample of data.
    2. **data** : ``list``
        A list of data that has been drawn from a univariate normal population.
    &#34;&#34;&#34;
    likelihood = 0
    for point in data:
        likelihood += norm.logpdf(x=point, loc=params[0], scale=params[1])
    return likelihood


def bivariate_normal_likelihood_function(params: list, data: list) -&gt; float:
    r&#34;&#34;&#34;
    Returns the likelihood of a vector of parameters being observed from a sample bivariate data of normal data. It can be used as objective function input for `scipy.optimize`&#39;s optimization methods. 

    Parameters
    ----------
    1. **params** : ``list``
        Array representing a vector of parameters, in this case the mean rate of returns, voledatilities and covariance for a bivariate normal distribution. *Important*: The vector must be order: 1. params[0] = \\(\mu_x\\), params[1]=\\(\mu_y\\), params[2] = \\(\sigma_x\\), params[3] = \\(\sigma_y\\), params[4] = \\(\rho_{xy} \cdot \sigma_x \cdot \sigma_y\\). The matrix is parameterized in this manner in order to interface more easily with `scipy.optimize.minimize`.
    2. **data** : ``list``
        A list of data that has been drawn from a bivariate normal population. Must be formatted in the following manner: `[ [x1,y1], [x2,y2],...]`

    .. notes::
        * the covariance matrix of a bivariate normal distribution must be positive semi-definite (PSD) and non-singular. PSD can be checked with the [Slyvester Criterion](https://en.wikipedia.org/wiki/Sylvester%27s_criterion) or [Cauchy-Schwarz Inequality](https://en.wikipedia.org/wiki/Cauchy%E2%80%93Schwarz_inequality#Probability_theory). Since sample variance will always be positive, this reduces to checking the determinant of the covariance matrix is greater than 0. This function will return `numpy.inf` if the covariance matrix is singular or non-positive semi-definite.

    &#34;&#34;&#34;
    mean = [params[0], params[1]]
    cov = [[params[2], params[4]], [params[4], params[3]]]

    determinant = params[2]*params[3] - params[4]**2
    if determinant == 0 or determinant &lt; 0 or determinant &lt; (10**(-constants[&#39;ACCURACY&#39;])):
        return inf

    likelihood = 0
    for point in data:
        likelihood += multivariate_normal.logpdf(x=point, mean=mean, cov=cov)
    return likelihood


def sample_percentile(data: List[float], percentile: float):
    &#34;&#34;&#34;
    Returns the observation in a sample data corresponding to the given percentile, i.e. the observation from a sorted sample where the percentage of the observations below that point is specified by the percentile. If the percentile falls between data points, the observation is smoothed based on the distance from the adjoining observations in the following manner,

    .. todo:: add latex here

    Parameters
    ----------
    1. **data** : ``list``
        Array representing the set of data whose percentile is to be calculated.
    2. **percentile**: ``float``
        The percentile corresponding to the desired observation.
    &#34;&#34;&#34;
    data.sort()

    obs_number = (len(data) + 1)*percentile
    extrapolate = obs_number - int(obs_number)

    if extrapolate == 0:
        return data[int(obs_number)-1]
    if obs_number &gt; len(data):
        return data[-1]
    first_index = int(obs_number) - 1
    second_index = first_index + 1
    weight = obs_number - int(obs_number)
    return (1-weight)*data[first_index] + weight*data[second_index]

def empirical_copula(sample: List[List[float]], x_order: float, y_order: float):
    &#34;&#34;&#34;
    Computes an empirical estimate of the copula distribution for a bivariate sample.
    &#34;&#34;&#34;
    n = len(sample)

    def x_order_bounds(test_point):
        return test_point &lt; x_order or test_point == x_order
    
    def y_order_bounds(test_point):
        return test_point &lt; y_order or test_point == y_order

    copula = [ 1 for point in sample if x_order_bounds(point[0]) and y_order_bounds(point[1])]
    return len(copula) / n

def sample_correlation(x: List[float], y: List[float]):
    &#34;&#34;&#34;
    Returns the sample correlation calculated using the Pearson correlation coefficient estimator,

    .. todo:: Pearson coefficient formula here

    Parameters
    ----------
    1. **x**: ``list``
        The *x* sample of paired data (*x*, *y*). Must preserve order with **y**.
    2. **y**: ``list``
        The *y* sample of paired data (*x*, *y*). Must preserve order with **x**.

    Raises 
    ------
    1. `scrilla.errors.SampleSizeError` :
        If the sample sizes do not meet the requirements for estimation, this error will be thrown.
    2. **ValueError** :
        If the denominator of the correlation coefficient becomes too small for floating point arithmetic, this error is thrown.

    .. todos ::
        * Possibly wrap the correlation coefficient numerator and denominator in `Decimal` class before calculation to bypass the **ValueError** that occurs in some samples where the denominator is too small for the arithmetic to detect.
    &#34;&#34;&#34;
    if len(x) != len(y):
        raise errors.SampleSizeError(&#39;Samples are not of comparable lengths&#39;)

    if len(x) in [0, 1]:
        raise errors.SampleSizeError(
            &#39;Sample correlation cannot be computed for a sample size less than or equal to 1.&#39;)

    sumproduct, sum_x_squared, sum_x, sum_y, sum_y_squared = 0, 0, 0, 0, 0
    n = len(x)
    for i, item in enumerate(x):
        sumproduct += item*y[i]
        sum_x += item
        sum_x_squared += item**2
        sum_y += y[i]
        sum_y_squared += y[i]**2
    correl_num = ((n*sumproduct) - sum_x*sum_y)
    correl_den = sqrt((n*sum_x_squared-sum_x**2)*(n*sum_y_squared-sum_y**2))

    # LET&#39;S DO SOME MATHEMATICS! (to get around division by zero!)
    #   Unfortunately, this only works when A and B &gt; 0 because log
    #       of a negative number only exists in complex plane.
    #   1. correl = A/B
    #   2. log(correl) = log(A/B) = log(A) - log(B)
    #   3. exp(log(correl)) = exp(log(A/B))
    #   4. correl = exp(log(A/B))
    if correl_num &gt; 0 and correl_den &gt; 0:
        log_correl = log(correl_num) - log(correl_den)
        correlation = exp(log_correl)
    else:
        if correl_den != 0:
            correlation = correl_num / correl_den
        else:
            raise ValueError(
                &#39;Denominator for correlation formula to small for division&#39;)

    return correlation


def recursive_rolling_correlation(correl_previous, new_x_observation, lost_x_obs,
                                  new_y_obs, lost_y_obs, n=settings.DEFAULT_ANALYSIS_PERIOD):

    pass


def sample_mean(x: List[float]) -&gt; float:
    r&#34;&#34;&#34;
    Returns the sample mean from a sample of data \\(\{x_1 , x_2, ... , x_n \}\\),

    $$ \bar{x} = \frac{\sum_{i=1}^{n} x_i}/{n} $$

    Parameters
    ----------
    1. **x**: ``List[Union[float,int]]``
        List containing a sample of numerical data.

    Raises 
    ------
    1. **scrilla.errors.SampleSizeError**
        If ``len(x)==0``, this error will be thrown.
    2. **ValueError**
        If the sample contains null or non-numerical data, this error will be thrown.
    &#34;&#34;&#34;
    xbar, n = 0, len(x)

    if not all(this_x is not None and isinstance(this_x, (float, int)) for this_x in x):
        raise ValueError(
            &#39;Sample contains null values&#39;)

    if n == 0:
        raise errors.SampleSizeError(
            &#39;Sample mean cannot be computed for a sample size of 0.&#39;)

    for i in x:
        xbar += i/n
    return xbar


def recursive_rolling_mean(xbar_previous, new_obs, lost_obs, n=settings.DEFAULT_ANALYSIS_PERIOD):
    xbar_next = xbar_previous + (new_obs - lost_obs)/n
    return xbar_next


def sample_variance(x: List[float]):
    r&#34;&#34;&#34;
    Returns the sample variance from a sample of data \\(\{x_1 , x_2, ... , x_n \}\\),

    $$ s^2=\frac{\sum_{i=1}^{n} (x_i - \bar{x})^2}/{n-1} $$

    Parameters
    ----------
    1. **x**: ``list``
        List containing a sample of numerical data.

    Raises 
    ------
    1. `scrilla.errors.SampleSizeError`
    &#34;&#34;&#34;

    mu, sigma, n = sample_mean(x=x), 0, len(x)

    if not all(this_x is not None and isinstance(this_x, (float, int)) for this_x in x):
        raise ValueError(
            &#39;Sample contains null values&#39;)

    if n in [0, 1]:
        raise errors.SampleSizeError(
            &#39;Sample variance cannot be computed for a sample size less than or equal to 1.&#39;)

    for i in x:
        sigma += ((i-mu)**2)/(n-1)
    return sigma


def recursive_rolling_variance(var_previous, xbar_previous, new_obs, lost_obs, n=settings.DEFAULT_ANALYSIS_PERIOD):
    xbar_new = recursive_rolling_mean(xbar_previous=xbar_previous, new_obs=new_obs,
                                      lost_obs=lost_obs, n=n)
    var_new = var_previous + \
        (n/(n-1))*((new_obs**2 - lost_obs**2)/n + (xbar_previous**2-xbar_new**2))
    return var_new


def sample_covariance(x: list, y: list):
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **x**: ``list``
        The *x* sample of paired data (*x*, *y*). Must preserve order with **y**.
    2. **y**: ``list``
        The *y* sample of paired data (*x*, *y*). Must preserve order with **x**.

    Raises 
    ------
    1. `scrilla.errors.SampleSizeError`
        If ``len(x) != len(y)`` (samples of incomparable length) or ``len(x) in [0,1]`` (insufficient data/degrees of freedom), this error will be thrown.
    &#34;&#34;&#34;

    if len(x) != len(y):
        raise errors.SampleSizeError(&#39;Samples are not of comparable length&#39;)

    if len(x) in [0, 1]:
        raise errors.SampleSizeError(
            &#39;Sample correlation cannot be computed for a sample size less than or equal to 1.&#39;)

    n, covariance = len(x), 0

    x_mean, y_mean = sample_mean(x=x), sample_mean(x=y)

    for i, item in enumerate(x):
        covariance += (item - x_mean)*(y[i] - y_mean) / (n - 1)

    return covariance


def recursive_rolling_covariance(covar_previous: float, new_x_obs: float, lost_x_obs: float, previous_x_bar: float, new_y_obs: float, lost_y_obs: float, previous_y_bar: float, n: int = settings.DEFAULT_ANALYSIS_PERIOD):
    new_sum_term = new_x_obs*new_y_obs - lost_x_obs*lost_y_obs
    xy_cross_term = previous_x_bar*(new_y_obs-lost_y_obs)
    yx_cross_term = previous_y_bar*(new_x_obs-lost_x_obs)
    perturbation = (new_x_obs-lost_x_obs)*(new_y_obs-lost_y_obs) / n
    numerator = new_sum_term - xy_cross_term - yx_cross_term - perturbation
    covar_new = covar_previous + numerator / (n-1)
    return covar_new


def simple_regression_beta(x: List[float], y: List[float]):
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **x**: ``list``
        The *x* sample of paired data (*x*, *y*). Must preserve order with **y**.
    2. **y**: ``list``
        The *y* sample of paired data (*x*, *y*). Must preserve order with **x**.

    Raises 
    ------
    1. `scrilla.errors.statistics.SampleSizeError`
        If ``len(x) != len(y)`` (samples of incomparable length) or ``len(x) &lt; 3`` (insufficient data/degrees of freedom), this error will be thrown.
    &#34;&#34;&#34;

    if len(x) != len(y):
        raise errors.SampleSizeError(f&#39;len(x) = {len(x)} != len(y) = {len(y)}&#39;)
    if len(x) &lt; 3:
        raise errors.SampleSizeError(
            f&#39;Sample size of {len(x)} is less than the necessary degrees of freedom (n &gt; 2) for regression estimation.&#39;)

    correl = sample_correlation(x=x, y=y)
    vol_x = sqrt(sample_variance(x=x))
    vol_y = sqrt(sample_variance(x=y))

    beta = correl * vol_y / vol_x
    return beta


def simple_regression_alpha(x: List[float], y: List[float]):
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **x**: ``list``
        The *x* sample of paired data (*x*, *y*). Must preserve order with **y**.
    2. **y**: ``list``
        The *y* sample of paired data (*x*, *y*). Must preserve order with **x**.

    Raises 
    ------
    1. `scrilla.errors.SampleSizeError`
        If ``len(x) != len(y)`` (samples of incomparable length) or ``len(x) &lt; 3`` (insufficient data/degrees of freedom), this error will be thrown.
    &#34;&#34;&#34;

    if len(x) != len(y):
        raise errors.SampleSizeError(
            f&#39;len(x) == {len(x)} != len(y) == {len(y)}&#39;)

    if len(x) &lt; 3:
        raise errors.SampleSizeError(
            f&#39;Sample size of {len(x)} is less than the necessary degrees of freedom (n &gt; 2) for regression estimation.&#39;)

    y_mean, x_mean = sample_mean(y), sample_mean(x)

    alpha = y_mean - simple_regression_beta(x=x, y=y)*x_mean
    return alpha


def qq_series_for_sample(sample: List[float]) -&gt; List[list]:
    &#34;&#34;&#34;
    Calculates the QQ series for a sample of data, i.e. the set defined by the ordered pair of sample percentiles and theoretical normal percentiles. A sample&#39;s normality can be assessed by how linear the result graph is.

    Parameters
    ----------
    1. **sample**: ``list``
        A sample of numerical data.
    &#34;&#34;&#34;
    qq_series = []
    n = len(sample)
    for i in range(len(sample)):
        percentile = (i + 0.5)/n
        percentile_sample = sample_percentile(
            data=sample, percentile=percentile)
        percentile_norm = norm.ppf(q=percentile)
        qq_series += [[percentile_norm, percentile_sample]]

    return qq_series


def standardize(x: List[float]):
    mu = sample_mean(x)
    sigma = sqrt(sample_variance(x))
    return [(this_x - mu)/sigma for this_x in x]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="scrilla.analysis.estimators.bivariate_normal_likelihood_function"><code class="name flex">
<span>def <span class="ident">bivariate_normal_likelihood_function</span></span>(<span>params: list, data: list) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the likelihood of a vector of parameters being observed from a sample bivariate data of normal data. It can be used as objective function input for <code>scipy.optimize</code>'s optimization methods. </p>
<h2 id="parameters">Parameters</h2>
<ol>
<li><strong>params</strong> : <code>list</code>
Array representing a vector of parameters, in this case the mean rate of returns, voledatilities and covariance for a bivariate normal distribution. <em>Important</em>: The vector must be order: 1. params[0] = \(\mu_x\), params[1]=\(\mu_y\), params[2] = \(\sigma_x\), params[3] = \(\sigma_y\), params[4] = \(\rho_{xy} \cdot \sigma_x \cdot \sigma_y\). The matrix is parameterized in this manner in order to interface more easily with <code>scipy.optimize.minimize</code>.</li>
<li><strong>data</strong> : <code>list</code>
A list of data that has been drawn from a bivariate normal population. Must be formatted in the following manner: <code>[ [x1,y1], [x2,y2],&hellip;]</code></li>
</ol>
<div class="admonition notes">
<p class="admonition-title">Notes</p>
<ul>
<li>the covariance matrix of a bivariate normal distribution must be positive semi-definite (PSD) and non-singular. PSD can be checked with the <a href="https://en.wikipedia.org/wiki/Sylvester%27s_criterion">Slyvester Criterion</a> or <a href="https://en.wikipedia.org/wiki/Cauchy%E2%80%93Schwarz_inequality#Probability_theory">Cauchy-Schwarz Inequality</a>. Since sample variance will always be positive, this reduces to checking the determinant of the covariance matrix is greater than 0. This function will return <code>numpy.inf</code> if the covariance matrix is singular or non-positive semi-definite.</li>
</ul>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bivariate_normal_likelihood_function(params: list, data: list) -&gt; float:
    r&#34;&#34;&#34;
    Returns the likelihood of a vector of parameters being observed from a sample bivariate data of normal data. It can be used as objective function input for `scipy.optimize`&#39;s optimization methods. 

    Parameters
    ----------
    1. **params** : ``list``
        Array representing a vector of parameters, in this case the mean rate of returns, voledatilities and covariance for a bivariate normal distribution. *Important*: The vector must be order: 1. params[0] = \\(\mu_x\\), params[1]=\\(\mu_y\\), params[2] = \\(\sigma_x\\), params[3] = \\(\sigma_y\\), params[4] = \\(\rho_{xy} \cdot \sigma_x \cdot \sigma_y\\). The matrix is parameterized in this manner in order to interface more easily with `scipy.optimize.minimize`.
    2. **data** : ``list``
        A list of data that has been drawn from a bivariate normal population. Must be formatted in the following manner: `[ [x1,y1], [x2,y2],...]`

    .. notes::
        * the covariance matrix of a bivariate normal distribution must be positive semi-definite (PSD) and non-singular. PSD can be checked with the [Slyvester Criterion](https://en.wikipedia.org/wiki/Sylvester%27s_criterion) or [Cauchy-Schwarz Inequality](https://en.wikipedia.org/wiki/Cauchy%E2%80%93Schwarz_inequality#Probability_theory). Since sample variance will always be positive, this reduces to checking the determinant of the covariance matrix is greater than 0. This function will return `numpy.inf` if the covariance matrix is singular or non-positive semi-definite.

    &#34;&#34;&#34;
    mean = [params[0], params[1]]
    cov = [[params[2], params[4]], [params[4], params[3]]]

    determinant = params[2]*params[3] - params[4]**2
    if determinant == 0 or determinant &lt; 0 or determinant &lt; (10**(-constants[&#39;ACCURACY&#39;])):
        return inf

    likelihood = 0
    for point in data:
        likelihood += multivariate_normal.logpdf(x=point, mean=mean, cov=cov)
    return likelihood</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.empirical_copula"><code class="name flex">
<span>def <span class="ident">empirical_copula</span></span>(<span>sample: List[List[float]], x_order: float, y_order: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes an empirical estimate of the copula distribution for a bivariate sample.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empirical_copula(sample: List[List[float]], x_order: float, y_order: float):
    &#34;&#34;&#34;
    Computes an empirical estimate of the copula distribution for a bivariate sample.
    &#34;&#34;&#34;
    n = len(sample)

    def x_order_bounds(test_point):
        return test_point &lt; x_order or test_point == x_order
    
    def y_order_bounds(test_point):
        return test_point &lt; y_order or test_point == y_order

    copula = [ 1 for point in sample if x_order_bounds(point[0]) and y_order_bounds(point[1])]
    return len(copula) / n</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.qq_series_for_sample"><code class="name flex">
<span>def <span class="ident">qq_series_for_sample</span></span>(<span>sample: List[float]) ‑> List[list]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the QQ series for a sample of data, i.e. the set defined by the ordered pair of sample percentiles and theoretical normal percentiles. A sample's normality can be assessed by how linear the result graph is.</p>
<h2 id="parameters">Parameters</h2>
<ol>
<li><strong>sample</strong>: <code>list</code>
A sample of numerical data.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qq_series_for_sample(sample: List[float]) -&gt; List[list]:
    &#34;&#34;&#34;
    Calculates the QQ series for a sample of data, i.e. the set defined by the ordered pair of sample percentiles and theoretical normal percentiles. A sample&#39;s normality can be assessed by how linear the result graph is.

    Parameters
    ----------
    1. **sample**: ``list``
        A sample of numerical data.
    &#34;&#34;&#34;
    qq_series = []
    n = len(sample)
    for i in range(len(sample)):
        percentile = (i + 0.5)/n
        percentile_sample = sample_percentile(
            data=sample, percentile=percentile)
        percentile_norm = norm.ppf(q=percentile)
        qq_series += [[percentile_norm, percentile_sample]]

    return qq_series</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.recursive_rolling_correlation"><code class="name flex">
<span>def <span class="ident">recursive_rolling_correlation</span></span>(<span>correl_previous, new_x_observation, lost_x_obs, new_y_obs, lost_y_obs, n=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recursive_rolling_correlation(correl_previous, new_x_observation, lost_x_obs,
                                  new_y_obs, lost_y_obs, n=settings.DEFAULT_ANALYSIS_PERIOD):

    pass</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.recursive_rolling_covariance"><code class="name flex">
<span>def <span class="ident">recursive_rolling_covariance</span></span>(<span>covar_previous: float, new_x_obs: float, lost_x_obs: float, previous_x_bar: float, new_y_obs: float, lost_y_obs: float, previous_y_bar: float, n: int = 100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recursive_rolling_covariance(covar_previous: float, new_x_obs: float, lost_x_obs: float, previous_x_bar: float, new_y_obs: float, lost_y_obs: float, previous_y_bar: float, n: int = settings.DEFAULT_ANALYSIS_PERIOD):
    new_sum_term = new_x_obs*new_y_obs - lost_x_obs*lost_y_obs
    xy_cross_term = previous_x_bar*(new_y_obs-lost_y_obs)
    yx_cross_term = previous_y_bar*(new_x_obs-lost_x_obs)
    perturbation = (new_x_obs-lost_x_obs)*(new_y_obs-lost_y_obs) / n
    numerator = new_sum_term - xy_cross_term - yx_cross_term - perturbation
    covar_new = covar_previous + numerator / (n-1)
    return covar_new</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.recursive_rolling_mean"><code class="name flex">
<span>def <span class="ident">recursive_rolling_mean</span></span>(<span>xbar_previous, new_obs, lost_obs, n=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recursive_rolling_mean(xbar_previous, new_obs, lost_obs, n=settings.DEFAULT_ANALYSIS_PERIOD):
    xbar_next = xbar_previous + (new_obs - lost_obs)/n
    return xbar_next</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.recursive_rolling_variance"><code class="name flex">
<span>def <span class="ident">recursive_rolling_variance</span></span>(<span>var_previous, xbar_previous, new_obs, lost_obs, n=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recursive_rolling_variance(var_previous, xbar_previous, new_obs, lost_obs, n=settings.DEFAULT_ANALYSIS_PERIOD):
    xbar_new = recursive_rolling_mean(xbar_previous=xbar_previous, new_obs=new_obs,
                                      lost_obs=lost_obs, n=n)
    var_new = var_previous + \
        (n/(n-1))*((new_obs**2 - lost_obs**2)/n + (xbar_previous**2-xbar_new**2))
    return var_new</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.sample_correlation"><code class="name flex">
<span>def <span class="ident">sample_correlation</span></span>(<span>x: List[float], y: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sample correlation calculated using the Pearson correlation coefficient estimator,</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Pearson coefficient formula here</p>
</div>
<h2 id="parameters">Parameters</h2>
<ol>
<li><strong>x</strong>: <code>list</code>
The <em>x</em> sample of paired data (<em>x</em>, <em>y</em>). Must preserve order with <strong>y</strong>.</li>
<li><strong>y</strong>: <code>list</code>
The <em>y</em> sample of paired data (<em>x</em>, <em>y</em>). Must preserve order with <strong>x</strong>.</li>
</ol>
<h2 id="raises">Raises</h2>
<ol>
<li><code><a title="scrilla.errors.SampleSizeError" href="../errors.html#scrilla.errors.SampleSizeError">SampleSizeError</a></code> :
If the sample sizes do not meet the requirements for estimation, this error will be thrown.</li>
<li><strong>ValueError</strong> :
If the denominator of the correlation coefficient becomes too small for floating point arithmetic, this error is thrown.</li>
</ol>
<p>.. todos ::
* Possibly wrap the correlation coefficient numerator and denominator in <code>Decimal</code> class before calculation to bypass the <strong>ValueError</strong> that occurs in some samples where the denominator is too small for the arithmetic to detect.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_correlation(x: List[float], y: List[float]):
    &#34;&#34;&#34;
    Returns the sample correlation calculated using the Pearson correlation coefficient estimator,

    .. todo:: Pearson coefficient formula here

    Parameters
    ----------
    1. **x**: ``list``
        The *x* sample of paired data (*x*, *y*). Must preserve order with **y**.
    2. **y**: ``list``
        The *y* sample of paired data (*x*, *y*). Must preserve order with **x**.

    Raises 
    ------
    1. `scrilla.errors.SampleSizeError` :
        If the sample sizes do not meet the requirements for estimation, this error will be thrown.
    2. **ValueError** :
        If the denominator of the correlation coefficient becomes too small for floating point arithmetic, this error is thrown.

    .. todos ::
        * Possibly wrap the correlation coefficient numerator and denominator in `Decimal` class before calculation to bypass the **ValueError** that occurs in some samples where the denominator is too small for the arithmetic to detect.
    &#34;&#34;&#34;
    if len(x) != len(y):
        raise errors.SampleSizeError(&#39;Samples are not of comparable lengths&#39;)

    if len(x) in [0, 1]:
        raise errors.SampleSizeError(
            &#39;Sample correlation cannot be computed for a sample size less than or equal to 1.&#39;)

    sumproduct, sum_x_squared, sum_x, sum_y, sum_y_squared = 0, 0, 0, 0, 0
    n = len(x)
    for i, item in enumerate(x):
        sumproduct += item*y[i]
        sum_x += item
        sum_x_squared += item**2
        sum_y += y[i]
        sum_y_squared += y[i]**2
    correl_num = ((n*sumproduct) - sum_x*sum_y)
    correl_den = sqrt((n*sum_x_squared-sum_x**2)*(n*sum_y_squared-sum_y**2))

    # LET&#39;S DO SOME MATHEMATICS! (to get around division by zero!)
    #   Unfortunately, this only works when A and B &gt; 0 because log
    #       of a negative number only exists in complex plane.
    #   1. correl = A/B
    #   2. log(correl) = log(A/B) = log(A) - log(B)
    #   3. exp(log(correl)) = exp(log(A/B))
    #   4. correl = exp(log(A/B))
    if correl_num &gt; 0 and correl_den &gt; 0:
        log_correl = log(correl_num) - log(correl_den)
        correlation = exp(log_correl)
    else:
        if correl_den != 0:
            correlation = correl_num / correl_den
        else:
            raise ValueError(
                &#39;Denominator for correlation formula to small for division&#39;)

    return correlation</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.sample_covariance"><code class="name flex">
<span>def <span class="ident">sample_covariance</span></span>(<span>x: list, y: list)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ol>
<li><strong>x</strong>: <code>list</code>
The <em>x</em> sample of paired data (<em>x</em>, <em>y</em>). Must preserve order with <strong>y</strong>.</li>
<li><strong>y</strong>: <code>list</code>
The <em>y</em> sample of paired data (<em>x</em>, <em>y</em>). Must preserve order with <strong>x</strong>.</li>
</ol>
<h2 id="raises">Raises</h2>
<ol>
<li><code><a title="scrilla.errors.SampleSizeError" href="../errors.html#scrilla.errors.SampleSizeError">SampleSizeError</a></code>
If <code>len(x) != len(y)</code> (samples of incomparable length) or <code>len(x) in [0,1]</code> (insufficient data/degrees of freedom), this error will be thrown.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_covariance(x: list, y: list):
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **x**: ``list``
        The *x* sample of paired data (*x*, *y*). Must preserve order with **y**.
    2. **y**: ``list``
        The *y* sample of paired data (*x*, *y*). Must preserve order with **x**.

    Raises 
    ------
    1. `scrilla.errors.SampleSizeError`
        If ``len(x) != len(y)`` (samples of incomparable length) or ``len(x) in [0,1]`` (insufficient data/degrees of freedom), this error will be thrown.
    &#34;&#34;&#34;

    if len(x) != len(y):
        raise errors.SampleSizeError(&#39;Samples are not of comparable length&#39;)

    if len(x) in [0, 1]:
        raise errors.SampleSizeError(
            &#39;Sample correlation cannot be computed for a sample size less than or equal to 1.&#39;)

    n, covariance = len(x), 0

    x_mean, y_mean = sample_mean(x=x), sample_mean(x=y)

    for i, item in enumerate(x):
        covariance += (item - x_mean)*(y[i] - y_mean) / (n - 1)

    return covariance</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.sample_mean"><code class="name flex">
<span>def <span class="ident">sample_mean</span></span>(<span>x: List[float]) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sample mean from a sample of data \({x_1 , x_2, &hellip; , x_n }\),</p>
<p><span><span class="MathJax_Preview"> \bar{x} = \frac{\sum_{i=1}^{n} x_i}/{n} </span><script type="math/tex; mode=display"> \bar{x} = \frac{\sum_{i=1}^{n} x_i}/{n} </script></span></p>
<h2 id="parameters">Parameters</h2>
<ol>
<li><strong>x</strong>: <code>List[Union[float,int]]</code>
List containing a sample of numerical data.</li>
</ol>
<h2 id="raises">Raises</h2>
<ol>
<li><strong>scrilla.errors.SampleSizeError</strong>
If <code>len(x)==0</code>, this error will be thrown.</li>
<li><strong>ValueError</strong>
If the sample contains null or non-numerical data, this error will be thrown.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_mean(x: List[float]) -&gt; float:
    r&#34;&#34;&#34;
    Returns the sample mean from a sample of data \\(\{x_1 , x_2, ... , x_n \}\\),

    $$ \bar{x} = \frac{\sum_{i=1}^{n} x_i}/{n} $$

    Parameters
    ----------
    1. **x**: ``List[Union[float,int]]``
        List containing a sample of numerical data.

    Raises 
    ------
    1. **scrilla.errors.SampleSizeError**
        If ``len(x)==0``, this error will be thrown.
    2. **ValueError**
        If the sample contains null or non-numerical data, this error will be thrown.
    &#34;&#34;&#34;
    xbar, n = 0, len(x)

    if not all(this_x is not None and isinstance(this_x, (float, int)) for this_x in x):
        raise ValueError(
            &#39;Sample contains null values&#39;)

    if n == 0:
        raise errors.SampleSizeError(
            &#39;Sample mean cannot be computed for a sample size of 0.&#39;)

    for i in x:
        xbar += i/n
    return xbar</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.sample_percentile"><code class="name flex">
<span>def <span class="ident">sample_percentile</span></span>(<span>data: List[float], percentile: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the observation in a sample data corresponding to the given percentile, i.e. the observation from a sorted sample where the percentage of the observations below that point is specified by the percentile. If the percentile falls between data points, the observation is smoothed based on the distance from the adjoining observations in the following manner,</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>add latex here</p>
</div>
<h2 id="parameters">Parameters</h2>
<ol>
<li><strong>data</strong> : <code>list</code>
Array representing the set of data whose percentile is to be calculated.</li>
<li><strong>percentile</strong>: <code>float</code>
The percentile corresponding to the desired observation.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_percentile(data: List[float], percentile: float):
    &#34;&#34;&#34;
    Returns the observation in a sample data corresponding to the given percentile, i.e. the observation from a sorted sample where the percentage of the observations below that point is specified by the percentile. If the percentile falls between data points, the observation is smoothed based on the distance from the adjoining observations in the following manner,

    .. todo:: add latex here

    Parameters
    ----------
    1. **data** : ``list``
        Array representing the set of data whose percentile is to be calculated.
    2. **percentile**: ``float``
        The percentile corresponding to the desired observation.
    &#34;&#34;&#34;
    data.sort()

    obs_number = (len(data) + 1)*percentile
    extrapolate = obs_number - int(obs_number)

    if extrapolate == 0:
        return data[int(obs_number)-1]
    if obs_number &gt; len(data):
        return data[-1]
    first_index = int(obs_number) - 1
    second_index = first_index + 1
    weight = obs_number - int(obs_number)
    return (1-weight)*data[first_index] + weight*data[second_index]</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.sample_variance"><code class="name flex">
<span>def <span class="ident">sample_variance</span></span>(<span>x: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sample variance from a sample of data \({x_1 , x_2, &hellip; , x_n }\),</p>
<p><span><span class="MathJax_Preview"> s^2=\frac{\sum_{i=1}^{n} (x_i - \bar{x})^2}/{n-1} </span><script type="math/tex; mode=display"> s^2=\frac{\sum_{i=1}^{n} (x_i - \bar{x})^2}/{n-1} </script></span></p>
<h2 id="parameters">Parameters</h2>
<ol>
<li><strong>x</strong>: <code>list</code>
List containing a sample of numerical data.</li>
</ol>
<h2 id="raises">Raises</h2>
<ol>
<li><code><a title="scrilla.errors.SampleSizeError" href="../errors.html#scrilla.errors.SampleSizeError">SampleSizeError</a></code></li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_variance(x: List[float]):
    r&#34;&#34;&#34;
    Returns the sample variance from a sample of data \\(\{x_1 , x_2, ... , x_n \}\\),

    $$ s^2=\frac{\sum_{i=1}^{n} (x_i - \bar{x})^2}/{n-1} $$

    Parameters
    ----------
    1. **x**: ``list``
        List containing a sample of numerical data.

    Raises 
    ------
    1. `scrilla.errors.SampleSizeError`
    &#34;&#34;&#34;

    mu, sigma, n = sample_mean(x=x), 0, len(x)

    if not all(this_x is not None and isinstance(this_x, (float, int)) for this_x in x):
        raise ValueError(
            &#39;Sample contains null values&#39;)

    if n in [0, 1]:
        raise errors.SampleSizeError(
            &#39;Sample variance cannot be computed for a sample size less than or equal to 1.&#39;)

    for i in x:
        sigma += ((i-mu)**2)/(n-1)
    return sigma</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.simple_regression_alpha"><code class="name flex">
<span>def <span class="ident">simple_regression_alpha</span></span>(<span>x: List[float], y: List[float])</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ol>
<li><strong>x</strong>: <code>list</code>
The <em>x</em> sample of paired data (<em>x</em>, <em>y</em>). Must preserve order with <strong>y</strong>.</li>
<li><strong>y</strong>: <code>list</code>
The <em>y</em> sample of paired data (<em>x</em>, <em>y</em>). Must preserve order with <strong>x</strong>.</li>
</ol>
<h2 id="raises">Raises</h2>
<ol>
<li><code><a title="scrilla.errors.SampleSizeError" href="../errors.html#scrilla.errors.SampleSizeError">SampleSizeError</a></code>
If <code>len(x) != len(y)</code> (samples of incomparable length) or <code>len(x) &lt; 3</code> (insufficient data/degrees of freedom), this error will be thrown.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_regression_alpha(x: List[float], y: List[float]):
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **x**: ``list``
        The *x* sample of paired data (*x*, *y*). Must preserve order with **y**.
    2. **y**: ``list``
        The *y* sample of paired data (*x*, *y*). Must preserve order with **x**.

    Raises 
    ------
    1. `scrilla.errors.SampleSizeError`
        If ``len(x) != len(y)`` (samples of incomparable length) or ``len(x) &lt; 3`` (insufficient data/degrees of freedom), this error will be thrown.
    &#34;&#34;&#34;

    if len(x) != len(y):
        raise errors.SampleSizeError(
            f&#39;len(x) == {len(x)} != len(y) == {len(y)}&#39;)

    if len(x) &lt; 3:
        raise errors.SampleSizeError(
            f&#39;Sample size of {len(x)} is less than the necessary degrees of freedom (n &gt; 2) for regression estimation.&#39;)

    y_mean, x_mean = sample_mean(y), sample_mean(x)

    alpha = y_mean - simple_regression_beta(x=x, y=y)*x_mean
    return alpha</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.simple_regression_beta"><code class="name flex">
<span>def <span class="ident">simple_regression_beta</span></span>(<span>x: List[float], y: List[float])</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ol>
<li><strong>x</strong>: <code>list</code>
The <em>x</em> sample of paired data (<em>x</em>, <em>y</em>). Must preserve order with <strong>y</strong>.</li>
<li><strong>y</strong>: <code>list</code>
The <em>y</em> sample of paired data (<em>x</em>, <em>y</em>). Must preserve order with <strong>x</strong>.</li>
</ol>
<h2 id="raises">Raises</h2>
<ol>
<li><code>scrilla.errors.statistics.SampleSizeError</code>
If <code>len(x) != len(y)</code> (samples of incomparable length) or <code>len(x) &lt; 3</code> (insufficient data/degrees of freedom), this error will be thrown.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_regression_beta(x: List[float], y: List[float]):
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **x**: ``list``
        The *x* sample of paired data (*x*, *y*). Must preserve order with **y**.
    2. **y**: ``list``
        The *y* sample of paired data (*x*, *y*). Must preserve order with **x**.

    Raises 
    ------
    1. `scrilla.errors.statistics.SampleSizeError`
        If ``len(x) != len(y)`` (samples of incomparable length) or ``len(x) &lt; 3`` (insufficient data/degrees of freedom), this error will be thrown.
    &#34;&#34;&#34;

    if len(x) != len(y):
        raise errors.SampleSizeError(f&#39;len(x) = {len(x)} != len(y) = {len(y)}&#39;)
    if len(x) &lt; 3:
        raise errors.SampleSizeError(
            f&#39;Sample size of {len(x)} is less than the necessary degrees of freedom (n &gt; 2) for regression estimation.&#39;)

    correl = sample_correlation(x=x, y=y)
    vol_x = sqrt(sample_variance(x=x))
    vol_y = sqrt(sample_variance(x=y))

    beta = correl * vol_y / vol_x
    return beta</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.standardize"><code class="name flex">
<span>def <span class="ident">standardize</span></span>(<span>x: List[float])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def standardize(x: List[float]):
    mu = sample_mean(x)
    sigma = sqrt(sample_variance(x))
    return [(this_x - mu)/sigma for this_x in x]</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.estimators.univariate_normal_likelihood_function"><code class="name flex">
<span>def <span class="ident">univariate_normal_likelihood_function</span></span>(<span>params: list, data: list) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>This function returns the likelihood of a vector of parameters being observed from a sample univariate data of normal data. It can be used as objective function input for <code>scipy.optimize</code>'s optimization methods. </p>
<h2 id="parameters">Parameters</h2>
<ol>
<li><strong>x</strong> : <code>list</code>
Array representing a vector of parameters , in this case the mean rate of return and volatility from a sample of data.</li>
<li><strong>data</strong> : <code>list</code>
A list of data that has been drawn from a univariate normal population.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def univariate_normal_likelihood_function(params: list, data: list) -&gt; float:
    &#34;&#34;&#34;
    This function returns the likelihood of a vector of parameters being observed from a sample univariate data of normal data. It can be used as objective function input for `scipy.optimize`&#39;s optimization methods. 

    Parameters
    ----------
    1. **x** : ``list``
        Array representing a vector of parameters , in this case the mean rate of return and volatility from a sample of data.
    2. **data** : ``list``
        A list of data that has been drawn from a univariate normal population.
    &#34;&#34;&#34;
    likelihood = 0
    for point in data:
        likelihood += norm.logpdf(x=point, loc=params[0], scale=params[1])
    return likelihood</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrilla.analysis" href="index.html">scrilla.analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="scrilla.analysis.estimators.bivariate_normal_likelihood_function" href="#scrilla.analysis.estimators.bivariate_normal_likelihood_function">bivariate_normal_likelihood_function</a></code></li>
<li><code><a title="scrilla.analysis.estimators.empirical_copula" href="#scrilla.analysis.estimators.empirical_copula">empirical_copula</a></code></li>
<li><code><a title="scrilla.analysis.estimators.qq_series_for_sample" href="#scrilla.analysis.estimators.qq_series_for_sample">qq_series_for_sample</a></code></li>
<li><code><a title="scrilla.analysis.estimators.recursive_rolling_correlation" href="#scrilla.analysis.estimators.recursive_rolling_correlation">recursive_rolling_correlation</a></code></li>
<li><code><a title="scrilla.analysis.estimators.recursive_rolling_covariance" href="#scrilla.analysis.estimators.recursive_rolling_covariance">recursive_rolling_covariance</a></code></li>
<li><code><a title="scrilla.analysis.estimators.recursive_rolling_mean" href="#scrilla.analysis.estimators.recursive_rolling_mean">recursive_rolling_mean</a></code></li>
<li><code><a title="scrilla.analysis.estimators.recursive_rolling_variance" href="#scrilla.analysis.estimators.recursive_rolling_variance">recursive_rolling_variance</a></code></li>
<li><code><a title="scrilla.analysis.estimators.sample_correlation" href="#scrilla.analysis.estimators.sample_correlation">sample_correlation</a></code></li>
<li><code><a title="scrilla.analysis.estimators.sample_covariance" href="#scrilla.analysis.estimators.sample_covariance">sample_covariance</a></code></li>
<li><code><a title="scrilla.analysis.estimators.sample_mean" href="#scrilla.analysis.estimators.sample_mean">sample_mean</a></code></li>
<li><code><a title="scrilla.analysis.estimators.sample_percentile" href="#scrilla.analysis.estimators.sample_percentile">sample_percentile</a></code></li>
<li><code><a title="scrilla.analysis.estimators.sample_variance" href="#scrilla.analysis.estimators.sample_variance">sample_variance</a></code></li>
<li><code><a title="scrilla.analysis.estimators.simple_regression_alpha" href="#scrilla.analysis.estimators.simple_regression_alpha">simple_regression_alpha</a></code></li>
<li><code><a title="scrilla.analysis.estimators.simple_regression_beta" href="#scrilla.analysis.estimators.simple_regression_beta">simple_regression_beta</a></code></li>
<li><code><a title="scrilla.analysis.estimators.standardize" href="#scrilla.analysis.estimators.standardize">standardize</a></code></li>
<li><code><a title="scrilla.analysis.estimators.univariate_normal_likelihood_function" href="#scrilla.analysis.estimators.univariate_normal_likelihood_function">univariate_normal_likelihood_function</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>