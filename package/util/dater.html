<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scrilla.util.dater API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrilla.util.dater</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
from datetime import date

import math
import holidays
from typing import Any, List, Tuple, Union

import dateutil.easter as easter

from scrilla.settings import DATE_FORMAT


def today() -&gt; datetime.date:
    &#34;&#34;&#34;
    Returns today&#39;s date
    &#34;&#34;&#34;
    return datetime.date.today()


def validate_order_of_dates(start_date: date, end_date: date) -&gt; Tuple[date, date]:
    &#34;&#34;&#34;
    Returns the inputted dates as an tuple ordered from earliest to latest.
    &#34;&#34;&#34;
    delta = (end_date - start_date).days
    if delta &lt; 0:
        return end_date, start_date
    return start_date, end_date


def parse(date_string: str) -&gt; Union[date, None]:
    &#34;&#34;&#34;
    Converts a date string in the &#39;YYYY-MM-DD&#39; format to a Python `datetime.date`.
    &#34;&#34;&#34;
    return datetime.datetime.strptime(date_string, DATE_FORMAT).date()


def validate_date(this_date: Any) -&gt; date:
    if isinstance(this_date, str):
        return parse(this_date)
    if not isinstance(this_date, date):
        raise ValueError(
            f&#39;{this_date} is neither date nor \&#39;{DATE_FORMAT}\&#39; formatted string&#39;)
    return this_date


def validate_date_range(start_date: Any, end_date: Any) -&gt; Tuple[date, date]:
    if isinstance(start_date, str):
        start_date = parse(start_date)
    elif not isinstance(start_date, date):
        raise ValueError(
            f&#39;{start_date} is neither date nor \&#39;{DATE_FORMAT}\&#39; formatted string&#39;)
    if isinstance(end_date, str):
        end_date = parse(end_date)
    elif not isinstance(end_date, date):
        raise ValueError(
            f&#39;{end_date} is neither date nor \&#39;{DATE_FORMAT}\&#39; formatted string&#39;)
    return validate_order_of_dates(start_date, end_date)


def validate_date_list(dates: Union[List[Union[datetime.date, str]]]) -&gt; Union[List[datetime.date], None]:
    &#34;&#34;&#34;

    Raises
    ------
    1. **ValueError**
        If the supplied list of dates contains unexpected data types, this error will be thrown.

    &#34;&#34;&#34;
    verified_dates = []
    for this_date in dates:
        if isinstance(this_date, str):
            verified_dates.append(parse(this_date))
            continue
        if isinstance(this_date, datetime.date):
            verified_dates.append(this_date)
            continue
        raise ValueError(
            f&#39;{this_date} is neither date nor \&#39;{DATE_FORMAT}\&#39;formatted string&#39;)
    return verified_dates


def to_string(this_date: Union[date, None] = None) -&gt; str:
    &#34;&#34;&#34; 
    Returns a datetime formatted as &#39;YYYY-MM-DD&#39;. If no date is provided, function will return today&#39;s formatted date.
    &#34;&#34;&#34;
    if this_date is None:
        return to_string(today())
    return datetime.datetime.strftime(this_date, DATE_FORMAT)


def is_date_today(this_date: Union[date, str]) -&gt; bool:
    return (validate_date(this_date) == datetime.date.today())


def is_future_date(this_date: Union[date, str]) -&gt; bool:
    return (validate_date(this_date) - today()).days &gt; 0


def truncate_future_from_date(this_date: Union[date, str]) -&gt; datetime.date:
    this_date = validate_date(this_date)
    if is_future_date(this_date):
        return today()
    return this_date


def last_close_date():
    right_now = datetime.datetime.now()
    trading_close_today = right_now.replace(hour=16)
    if right_now &gt; trading_close_today:
        return right_now.date()
    return get_previous_business_date(right_now.date())


def is_date_weekend(this_date: Union[date, str]) -&gt; bool:
    return validate_date(this_date).weekday() in [5, 6]


def is_date_holiday(this_date: Union[date, str]) -&gt; bool:
    this_date = validate_date(this_date)
    us_holidays = holidays.UnitedStates(years=this_date.year)
    # generate list without columbus day and veterans day since markets are open on those days
    trading_holidays = [
        &#34;Columbus Day&#34;, &#34;Columbus Day (Observed)&#34;, &#34;Veterans Day&#34;, &#34;Veterans Day (Observed)&#34;]

    # markets are open
    # see here: https://www.barrons.com/articles/stock-market-open-close-new-years-eve-monday-hours-51640891577
    if datetime.datetime(year=this_date.year+1, month=1, day=1).weekday() in [5, 6]:
        trading_holidays += [&#34;New Year&#39;s Day (Observed)&#34;]

    custom_holidays = [that_date for that_date in list(
        us_holidays) if us_holidays[that_date] not in trading_holidays]

    # add good friday to list since markets are closed on good friday
    custom_holidays.append(easter.easter(
        year=this_date.year) - datetime.timedelta(days=2))

    return (this_date in custom_holidays)


def get_last_trading_date() -&gt; date:
    &#34;&#34;&#34;
    Returns
    -------
    The last full trading day. If today is a trading day and the time is past market close, today&#39;s date will be returned. Otherwise, the previous business day&#39;s date will be returned. 
    &#34;&#34;&#34;
    todays_date = datetime.datetime.now()
    if is_date_holiday(todays_date) or is_date_weekend(todays_date):
        return get_previous_business_date(todays_date.date())
    return last_close_date()


def this_date_or_last_trading_date(this_date: Union[date, str, None] = None) -&gt; date:
    if this_date is None:
        return get_last_trading_date()
    this_date = validate_date(this_date)
    if is_date_holiday(this_date) or is_date_weekend(this_date):
        return get_previous_business_date(this_date)
    if is_date_today(this_date):
        return last_close_date()
    return this_date


def format_date_range(start_date: date, end_date: date) -&gt; str:
    result = &#34;&#34;
    if start_date is not None:
        start_string = to_string(start_date)
        result += f&#39;From {start_string}&#39;
    if end_date is not None:
        end_string = to_string(end_date)
        result += f&#39; Until {end_string}&#39;
    return result


def is_trading_date(this_date: Union[date, str]) -&gt; bool:
    this_date = validate_date(this_date)
    return not is_date_weekend(this_date) and not is_date_holiday(this_date)


def intersect_with_trading_dates(date_key_dict: dict) -&gt; dict:
    return {this_date: date_key_dict[this_date] for this_date in date_key_dict if is_trading_date(this_date)}


def get_holidays_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; int:
    if isinstance(start_date, date):
        start_date = to_string(start_date)
    if isinstance(end_date, date):
        end_date = to_string(end_date)
    us_holidays = holidays.UnitedStates()
    return len(us_holidays[start_date: end_date])

# YYYY-MM-DD


def consecutive_trading_days(start_date: Union[date, str], end_date: Union[date, str]) -&gt; bool:
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **start_date_string**: ``str``
        The start date of the time period under consideration. Must be formatted &#34;YYYY-MM-DD&#34;
    2. **end_date_string**: ``str``
        The end date of the time period under consideration. Must be formatted &#34;YYYY-MM-DD&#34;

    Returns 
    -------
    True
        if start_date_string and end_date_string are consecutive trading days, i.e. Tuesday -&gt; Wednesday or Friday -&gt; Monday,
        or Tuesday -&gt; Thursday where Wednesday is a Holiday.
    False
        if start_date_string and end_date_string are NOT consecutive trading days.
    &#34;&#34;&#34;
    start_date, end_date = validate_date_range(start_date, end_date)

    if is_date_weekend(start_date) or is_date_weekend(end_date):
        return False

    delta = (end_date - start_date).days

    if delta &lt; 0:
        start_date, end_date = end_date, start_date
        delta = end_date - start_date

    holiday_count = get_holidays_between(
        start_date=start_date, end_date=end_date)

    if (delta - holiday_count) == 0:
        return False

    if (delta - holiday_count) == 1:
        return True

    if ((delta - holiday_count) &gt; 1 and (delta - holiday_count) &lt; 4):
        start_week, end_week = start_date.isocalendar()[
            1], end_date.isocalendar()[1]

        if start_week == end_week:
            return False

        return True

    return False


def dates_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; List[date]:
    &#34;&#34;&#34;
    Returns a list of dates between the inputted dates. &#34;Between&#34; is used in the inclusive sense, i.e. the list includes `start_date` and `end_date`.

    Parameters
    ----------
    1. **start_date**: ``datetime.date``
        Start date of the date range.
    2. **end_date**: ``datetime.date``
        End date of the date range. 
    &#34;&#34;&#34;
    start_date, end_date = validate_date_range(start_date, end_date)
    return [start_date + datetime.timedelta(x) for x in range((end_date - start_date).days+1)]


def days_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; int:
    start_date, end_date = validate_date_range(start_date, end_date)
    return int((end_date - start_date).days) + 1

# excludes start_date


def business_dates_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; List[date]:
    &#34;&#34;&#34;
    Returns a list of business dates between the inputted dates. &#34;Between&#34; is used in the inclusive sense, i.e. the list includes `start_date` and `dates`

    Parameters
    ----------
    1. **start_date**: ``datetime.date``
        Start date of the date range.
    2. **end_date**: ``datetime.date``
        End date of the date range. 
    &#34;&#34;&#34;
    start_date, end_date = validate_date_range(start_date, end_date)
    dates = []
    for x in range((end_date - start_date).days+1):
        this_date = start_date + datetime.timedelta(x)
        if is_trading_date(this_date):
            dates.append(this_date)
    return dates


def business_days_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; List[int]:
    start_date, end_date = validate_date_range(start_date, end_date)
    dates = dates_between(start_date, end_date)
    return len([1 for this_date in dates if is_trading_date(this_date)])


def weekends_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; List[int]:
    start_date, end_date = validate_date_range(start_date, end_date)
    dates = dates_between(start_date, end_date)
    return len([1 for day in dates if day.weekday() &gt; 4])


def decrement_date_by_days(start_date: Union[date, str], days: int):
    start_date = validate_date(start_date)
    while days &gt; 0:
        days -= 1
        start_date -= datetime.timedelta(days=1)
    return start_date


def decrement_date_by_business_days(start_date: Union[date, str], business_days: int) -&gt; date:
    &#34;&#34;&#34;
    Subtracts `business_days`, ignoring weekends and trading holidays, from `start_date`
    &#34;&#34;&#34;
    start_date = validate_date(start_date)
    first_pass = True
    while business_days &gt; 0:
        if is_trading_date(start_date):
            if first_pass:
                first_pass = False
            else:
                business_days -= 1

        if business_days &gt; 0:
            start_date -= datetime.timedelta(days=1)

    return start_date


def increment_date_by_business_days(start_date: Union[date, str], business_days: int) -&gt; date:
    start_date = validate_date(start_date)
    while business_days &gt; 0:
        if is_trading_date(start_date):
            business_days -= 1
        start_date += datetime.timedelta(days=1)
    return start_date


def get_next_business_date(this_date: Union[date, str]) -&gt; date:
    this_date = validate_date(this_date)
    while not is_trading_date(this_date):
        this_date += datetime.timedelta(days=1)
    return this_date


def get_previous_business_date(this_date: Union[date, str]) -&gt; date:
    this_date = decrement_date_by_days(start_date=this_date, days=1)
    while not is_trading_date(this_date):
        this_date -= datetime.timedelta(days=1)
    return this_date

# in years


def get_time_to_next_month(todays_date: date = today(), trading_days: int = 252) -&gt; float:
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **todays_date**: ``date``
        *Optional*. Reference date for calculation.
    2. **trading_days**: ``int``
        *Optional*. Number of trading days in a year. Defaults to 252.

    &#34;&#34;&#34;
    # TODO: what if first day of the month falls on non-trading days?
    todays_date = datetime.date.today()
    next_month = datetime.date(
        year=todays_date.year, month=(todays_date.month+1), day=1)
    return ((next_month - todays_date).days / trading_days)


def get_time_to_next_year(todays_date: date = today(), trading_days: int = 252) -&gt; float:
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **todays_date**: ``date``
        *Optional*. Reference date for calculation.
    2. **trading_days**: ``int``
        *Optional*. Number of trading days in a year. Defaults to 252.
    &#34;&#34;&#34;
    # TODO: what if first day of year falls on non-trading day?
    #       which it will, by definition. fuckwit.
    next_year = datetime.datetime(year=todays_date.year+1, day=1, month=1)
    return ((next_year - todays_date).days / trading_days)


def get_time_to_next_quarter(todays_date: date = today(), trading_days: int = 252) -&gt; float:
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **todays_date**: ``date``
        *Optional*. Reference date for calculation.
    2. **trading_days**: ``int``
        *Optional*. Number of trading days in a year. Defaults to 252.
    &#34;&#34;&#34;
    # TODO: what if first day of quarter falls on non-trading days?

    first_q = datetime.date(year=todays_date.year, month=1, day=1)
    second_q = datetime.date(year=todays_date.year, month=4, day=1)
    third_q = datetime.date(year=todays_date.year, month=7, day=1)
    fourth_q = datetime.date(year=todays_date.year, month=10, day=1)
    next_first_q = datetime.date(year=(todays_date.year+1), month=1, day=1)

    first_delta = (first_q - todays_date).days / trading_days
    second_delta = (second_q - todays_date).days / trading_days
    third_delta = (third_q - todays_date).days / trading_days
    fourth_delta = (fourth_q - todays_date).days / trading_days
    next_delta = (next_first_q - todays_date).days / trading_days

    return min(i for i in [first_delta, second_delta, third_delta, fourth_delta, next_delta] if i &gt; 0)


def get_time_to_next_period(starting_date: Union[date, str], period: float) -&gt; float:
    &#34;&#34;&#34;
    Divides the year into segments of equal length &#39;period&#39; and then calculates the time from today until 
    the next period. 

    Parameters
    ---------- 
    1. **starting_date**: ``Union[date, str]``
        Starting day of the period. Not to be confused with today. This is the point in time when the recurring event started. 
    2. **period**: float
        Length of one period, measured in years. 
    &#34;&#34;&#34;
    if period is None:
        return 0

    starting_date = validate_date(starting_date)
    todays_date = datetime.date.today()
    floored_days = math.floor(365*period)

    while ((starting_date - todays_date).days &lt; 0):
        starting_date += datetime.timedelta(days=floored_days)

    return float((todays_date - starting_date).days / 365)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="scrilla.util.dater.business_dates_between"><code class="name flex">
<span>def <span class="ident">business_dates_between</span></span>(<span>start_date: Union[datetime.date, str], end_date: Union[datetime.date, str]) ‑> List[datetime.date]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of business dates between the inputted dates. "Between" is used in the inclusive sense, i.e. the list includes <code>start_date</code> and <code>dates</code></p>
<h2 id="parameters">Parameters</h2>
<ol>
<li><strong>start_date</strong>: <code>datetime.date</code>
Start date of the date range.</li>
<li><strong>end_date</strong>: <code>datetime.date</code>
End date of the date range.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def business_dates_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; List[date]:
    &#34;&#34;&#34;
    Returns a list of business dates between the inputted dates. &#34;Between&#34; is used in the inclusive sense, i.e. the list includes `start_date` and `dates`

    Parameters
    ----------
    1. **start_date**: ``datetime.date``
        Start date of the date range.
    2. **end_date**: ``datetime.date``
        End date of the date range. 
    &#34;&#34;&#34;
    start_date, end_date = validate_date_range(start_date, end_date)
    dates = []
    for x in range((end_date - start_date).days+1):
        this_date = start_date + datetime.timedelta(x)
        if is_trading_date(this_date):
            dates.append(this_date)
    return dates</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.business_days_between"><code class="name flex">
<span>def <span class="ident">business_days_between</span></span>(<span>start_date: Union[datetime.date, str], end_date: Union[datetime.date, str]) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def business_days_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; List[int]:
    start_date, end_date = validate_date_range(start_date, end_date)
    dates = dates_between(start_date, end_date)
    return len([1 for this_date in dates if is_trading_date(this_date)])</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.consecutive_trading_days"><code class="name flex">
<span>def <span class="ident">consecutive_trading_days</span></span>(<span>start_date: Union[datetime.date, str], end_date: Union[datetime.date, str]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ol>
<li><strong>start_date_string</strong>: <code>str</code>
The start date of the time period under consideration. Must be formatted "YYYY-MM-DD"</li>
<li><strong>end_date_string</strong>: <code>str</code>
The end date of the time period under consideration. Must be formatted "YYYY-MM-DD"</li>
</ol>
<h2 id="returns">Returns</h2>
<p>True
if start_date_string and end_date_string are consecutive trading days, i.e. Tuesday -&gt; Wednesday or Friday -&gt; Monday,
or Tuesday -&gt; Thursday where Wednesday is a Holiday.
False
if start_date_string and end_date_string are NOT consecutive trading days.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consecutive_trading_days(start_date: Union[date, str], end_date: Union[date, str]) -&gt; bool:
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **start_date_string**: ``str``
        The start date of the time period under consideration. Must be formatted &#34;YYYY-MM-DD&#34;
    2. **end_date_string**: ``str``
        The end date of the time period under consideration. Must be formatted &#34;YYYY-MM-DD&#34;

    Returns 
    -------
    True
        if start_date_string and end_date_string are consecutive trading days, i.e. Tuesday -&gt; Wednesday or Friday -&gt; Monday,
        or Tuesday -&gt; Thursday where Wednesday is a Holiday.
    False
        if start_date_string and end_date_string are NOT consecutive trading days.
    &#34;&#34;&#34;
    start_date, end_date = validate_date_range(start_date, end_date)

    if is_date_weekend(start_date) or is_date_weekend(end_date):
        return False

    delta = (end_date - start_date).days

    if delta &lt; 0:
        start_date, end_date = end_date, start_date
        delta = end_date - start_date

    holiday_count = get_holidays_between(
        start_date=start_date, end_date=end_date)

    if (delta - holiday_count) == 0:
        return False

    if (delta - holiday_count) == 1:
        return True

    if ((delta - holiday_count) &gt; 1 and (delta - holiday_count) &lt; 4):
        start_week, end_week = start_date.isocalendar()[
            1], end_date.isocalendar()[1]

        if start_week == end_week:
            return False

        return True

    return False</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.dates_between"><code class="name flex">
<span>def <span class="ident">dates_between</span></span>(<span>start_date: Union[datetime.date, str], end_date: Union[datetime.date, str]) ‑> List[datetime.date]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of dates between the inputted dates. "Between" is used in the inclusive sense, i.e. the list includes <code>start_date</code> and <code>end_date</code>.</p>
<h2 id="parameters">Parameters</h2>
<ol>
<li><strong>start_date</strong>: <code>datetime.date</code>
Start date of the date range.</li>
<li><strong>end_date</strong>: <code>datetime.date</code>
End date of the date range.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dates_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; List[date]:
    &#34;&#34;&#34;
    Returns a list of dates between the inputted dates. &#34;Between&#34; is used in the inclusive sense, i.e. the list includes `start_date` and `end_date`.

    Parameters
    ----------
    1. **start_date**: ``datetime.date``
        Start date of the date range.
    2. **end_date**: ``datetime.date``
        End date of the date range. 
    &#34;&#34;&#34;
    start_date, end_date = validate_date_range(start_date, end_date)
    return [start_date + datetime.timedelta(x) for x in range((end_date - start_date).days+1)]</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.days_between"><code class="name flex">
<span>def <span class="ident">days_between</span></span>(<span>start_date: Union[datetime.date, str], end_date: Union[datetime.date, str]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def days_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; int:
    start_date, end_date = validate_date_range(start_date, end_date)
    return int((end_date - start_date).days) + 1</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.decrement_date_by_business_days"><code class="name flex">
<span>def <span class="ident">decrement_date_by_business_days</span></span>(<span>start_date: Union[datetime.date, str], business_days: int) ‑> datetime.date</span>
</code></dt>
<dd>
<div class="desc"><p>Subtracts <code>business_days</code>, ignoring weekends and trading holidays, from <code>start_date</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrement_date_by_business_days(start_date: Union[date, str], business_days: int) -&gt; date:
    &#34;&#34;&#34;
    Subtracts `business_days`, ignoring weekends and trading holidays, from `start_date`
    &#34;&#34;&#34;
    start_date = validate_date(start_date)
    first_pass = True
    while business_days &gt; 0:
        if is_trading_date(start_date):
            if first_pass:
                first_pass = False
            else:
                business_days -= 1

        if business_days &gt; 0:
            start_date -= datetime.timedelta(days=1)

    return start_date</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.decrement_date_by_days"><code class="name flex">
<span>def <span class="ident">decrement_date_by_days</span></span>(<span>start_date: Union[datetime.date, str], days: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrement_date_by_days(start_date: Union[date, str], days: int):
    start_date = validate_date(start_date)
    while days &gt; 0:
        days -= 1
        start_date -= datetime.timedelta(days=1)
    return start_date</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.format_date_range"><code class="name flex">
<span>def <span class="ident">format_date_range</span></span>(<span>start_date: datetime.date, end_date: datetime.date) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_date_range(start_date: date, end_date: date) -&gt; str:
    result = &#34;&#34;
    if start_date is not None:
        start_string = to_string(start_date)
        result += f&#39;From {start_string}&#39;
    if end_date is not None:
        end_string = to_string(end_date)
        result += f&#39; Until {end_string}&#39;
    return result</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.get_holidays_between"><code class="name flex">
<span>def <span class="ident">get_holidays_between</span></span>(<span>start_date: Union[datetime.date, str], end_date: Union[datetime.date, str]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_holidays_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; int:
    if isinstance(start_date, date):
        start_date = to_string(start_date)
    if isinstance(end_date, date):
        end_date = to_string(end_date)
    us_holidays = holidays.UnitedStates()
    return len(us_holidays[start_date: end_date])</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.get_last_trading_date"><code class="name flex">
<span>def <span class="ident">get_last_trading_date</span></span>(<span>) ‑> datetime.date</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>The last full trading day. If today is a trading day and the time is past market close, today's date will be returned. Otherwise, the previous business day's date will be returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_trading_date() -&gt; date:
    &#34;&#34;&#34;
    Returns
    -------
    The last full trading day. If today is a trading day and the time is past market close, today&#39;s date will be returned. Otherwise, the previous business day&#39;s date will be returned. 
    &#34;&#34;&#34;
    todays_date = datetime.datetime.now()
    if is_date_holiday(todays_date) or is_date_weekend(todays_date):
        return get_previous_business_date(todays_date.date())
    return last_close_date()</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.get_next_business_date"><code class="name flex">
<span>def <span class="ident">get_next_business_date</span></span>(<span>this_date: Union[datetime.date, str]) ‑> datetime.date</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_next_business_date(this_date: Union[date, str]) -&gt; date:
    this_date = validate_date(this_date)
    while not is_trading_date(this_date):
        this_date += datetime.timedelta(days=1)
    return this_date</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.get_previous_business_date"><code class="name flex">
<span>def <span class="ident">get_previous_business_date</span></span>(<span>this_date: Union[datetime.date, str]) ‑> datetime.date</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_previous_business_date(this_date: Union[date, str]) -&gt; date:
    this_date = decrement_date_by_days(start_date=this_date, days=1)
    while not is_trading_date(this_date):
        this_date -= datetime.timedelta(days=1)
    return this_date</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.get_time_to_next_month"><code class="name flex">
<span>def <span class="ident">get_time_to_next_month</span></span>(<span>todays_date: datetime.date = datetime.date(2022, 4, 26), trading_days: int = 252) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ol>
<li><strong>todays_date</strong>: <code>date</code>
<em>Optional</em>. Reference date for calculation.</li>
<li><strong>trading_days</strong>: <code>int</code>
<em>Optional</em>. Number of trading days in a year. Defaults to 252.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_to_next_month(todays_date: date = today(), trading_days: int = 252) -&gt; float:
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **todays_date**: ``date``
        *Optional*. Reference date for calculation.
    2. **trading_days**: ``int``
        *Optional*. Number of trading days in a year. Defaults to 252.

    &#34;&#34;&#34;
    # TODO: what if first day of the month falls on non-trading days?
    todays_date = datetime.date.today()
    next_month = datetime.date(
        year=todays_date.year, month=(todays_date.month+1), day=1)
    return ((next_month - todays_date).days / trading_days)</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.get_time_to_next_period"><code class="name flex">
<span>def <span class="ident">get_time_to_next_period</span></span>(<span>starting_date: Union[datetime.date, str], period: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Divides the year into segments of equal length 'period' and then calculates the time from today until
the next period. </p>
<h2 id="parameters">Parameters</h2>
<ol>
<li><strong>starting_date</strong>: <code>Union[date, str]</code>
Starting day of the period. Not to be confused with today. This is the point in time when the recurring event started. </li>
<li><strong>period</strong>: float
Length of one period, measured in years.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_to_next_period(starting_date: Union[date, str], period: float) -&gt; float:
    &#34;&#34;&#34;
    Divides the year into segments of equal length &#39;period&#39; and then calculates the time from today until 
    the next period. 

    Parameters
    ---------- 
    1. **starting_date**: ``Union[date, str]``
        Starting day of the period. Not to be confused with today. This is the point in time when the recurring event started. 
    2. **period**: float
        Length of one period, measured in years. 
    &#34;&#34;&#34;
    if period is None:
        return 0

    starting_date = validate_date(starting_date)
    todays_date = datetime.date.today()
    floored_days = math.floor(365*period)

    while ((starting_date - todays_date).days &lt; 0):
        starting_date += datetime.timedelta(days=floored_days)

    return float((todays_date - starting_date).days / 365)</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.get_time_to_next_quarter"><code class="name flex">
<span>def <span class="ident">get_time_to_next_quarter</span></span>(<span>todays_date: datetime.date = datetime.date(2022, 4, 26), trading_days: int = 252) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ol>
<li><strong>todays_date</strong>: <code>date</code>
<em>Optional</em>. Reference date for calculation.</li>
<li><strong>trading_days</strong>: <code>int</code>
<em>Optional</em>. Number of trading days in a year. Defaults to 252.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_to_next_quarter(todays_date: date = today(), trading_days: int = 252) -&gt; float:
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **todays_date**: ``date``
        *Optional*. Reference date for calculation.
    2. **trading_days**: ``int``
        *Optional*. Number of trading days in a year. Defaults to 252.
    &#34;&#34;&#34;
    # TODO: what if first day of quarter falls on non-trading days?

    first_q = datetime.date(year=todays_date.year, month=1, day=1)
    second_q = datetime.date(year=todays_date.year, month=4, day=1)
    third_q = datetime.date(year=todays_date.year, month=7, day=1)
    fourth_q = datetime.date(year=todays_date.year, month=10, day=1)
    next_first_q = datetime.date(year=(todays_date.year+1), month=1, day=1)

    first_delta = (first_q - todays_date).days / trading_days
    second_delta = (second_q - todays_date).days / trading_days
    third_delta = (third_q - todays_date).days / trading_days
    fourth_delta = (fourth_q - todays_date).days / trading_days
    next_delta = (next_first_q - todays_date).days / trading_days

    return min(i for i in [first_delta, second_delta, third_delta, fourth_delta, next_delta] if i &gt; 0)</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.get_time_to_next_year"><code class="name flex">
<span>def <span class="ident">get_time_to_next_year</span></span>(<span>todays_date: datetime.date = datetime.date(2022, 4, 26), trading_days: int = 252) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<ol>
<li><strong>todays_date</strong>: <code>date</code>
<em>Optional</em>. Reference date for calculation.</li>
<li><strong>trading_days</strong>: <code>int</code>
<em>Optional</em>. Number of trading days in a year. Defaults to 252.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_time_to_next_year(todays_date: date = today(), trading_days: int = 252) -&gt; float:
    &#34;&#34;&#34;
    Parameters
    ----------
    1. **todays_date**: ``date``
        *Optional*. Reference date for calculation.
    2. **trading_days**: ``int``
        *Optional*. Number of trading days in a year. Defaults to 252.
    &#34;&#34;&#34;
    # TODO: what if first day of year falls on non-trading day?
    #       which it will, by definition. fuckwit.
    next_year = datetime.datetime(year=todays_date.year+1, day=1, month=1)
    return ((next_year - todays_date).days / trading_days)</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.increment_date_by_business_days"><code class="name flex">
<span>def <span class="ident">increment_date_by_business_days</span></span>(<span>start_date: Union[datetime.date, str], business_days: int) ‑> datetime.date</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increment_date_by_business_days(start_date: Union[date, str], business_days: int) -&gt; date:
    start_date = validate_date(start_date)
    while business_days &gt; 0:
        if is_trading_date(start_date):
            business_days -= 1
        start_date += datetime.timedelta(days=1)
    return start_date</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.intersect_with_trading_dates"><code class="name flex">
<span>def <span class="ident">intersect_with_trading_dates</span></span>(<span>date_key_dict: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersect_with_trading_dates(date_key_dict: dict) -&gt; dict:
    return {this_date: date_key_dict[this_date] for this_date in date_key_dict if is_trading_date(this_date)}</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.is_date_holiday"><code class="name flex">
<span>def <span class="ident">is_date_holiday</span></span>(<span>this_date: Union[datetime.date, str]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_date_holiday(this_date: Union[date, str]) -&gt; bool:
    this_date = validate_date(this_date)
    us_holidays = holidays.UnitedStates(years=this_date.year)
    # generate list without columbus day and veterans day since markets are open on those days
    trading_holidays = [
        &#34;Columbus Day&#34;, &#34;Columbus Day (Observed)&#34;, &#34;Veterans Day&#34;, &#34;Veterans Day (Observed)&#34;]

    # markets are open
    # see here: https://www.barrons.com/articles/stock-market-open-close-new-years-eve-monday-hours-51640891577
    if datetime.datetime(year=this_date.year+1, month=1, day=1).weekday() in [5, 6]:
        trading_holidays += [&#34;New Year&#39;s Day (Observed)&#34;]

    custom_holidays = [that_date for that_date in list(
        us_holidays) if us_holidays[that_date] not in trading_holidays]

    # add good friday to list since markets are closed on good friday
    custom_holidays.append(easter.easter(
        year=this_date.year) - datetime.timedelta(days=2))

    return (this_date in custom_holidays)</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.is_date_today"><code class="name flex">
<span>def <span class="ident">is_date_today</span></span>(<span>this_date: Union[datetime.date, str]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_date_today(this_date: Union[date, str]) -&gt; bool:
    return (validate_date(this_date) == datetime.date.today())</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.is_date_weekend"><code class="name flex">
<span>def <span class="ident">is_date_weekend</span></span>(<span>this_date: Union[datetime.date, str]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_date_weekend(this_date: Union[date, str]) -&gt; bool:
    return validate_date(this_date).weekday() in [5, 6]</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.is_future_date"><code class="name flex">
<span>def <span class="ident">is_future_date</span></span>(<span>this_date: Union[datetime.date, str]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_future_date(this_date: Union[date, str]) -&gt; bool:
    return (validate_date(this_date) - today()).days &gt; 0</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.is_trading_date"><code class="name flex">
<span>def <span class="ident">is_trading_date</span></span>(<span>this_date: Union[datetime.date, str]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_trading_date(this_date: Union[date, str]) -&gt; bool:
    this_date = validate_date(this_date)
    return not is_date_weekend(this_date) and not is_date_holiday(this_date)</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.last_close_date"><code class="name flex">
<span>def <span class="ident">last_close_date</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last_close_date():
    right_now = datetime.datetime.now()
    trading_close_today = right_now.replace(hour=16)
    if right_now &gt; trading_close_today:
        return right_now.date()
    return get_previous_business_date(right_now.date())</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>date_string: str) ‑> Optional[datetime.date]</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a date string in the 'YYYY-MM-DD' format to a Python <code>datetime.date</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(date_string: str) -&gt; Union[date, None]:
    &#34;&#34;&#34;
    Converts a date string in the &#39;YYYY-MM-DD&#39; format to a Python `datetime.date`.
    &#34;&#34;&#34;
    return datetime.datetime.strptime(date_string, DATE_FORMAT).date()</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.this_date_or_last_trading_date"><code class="name flex">
<span>def <span class="ident">this_date_or_last_trading_date</span></span>(<span>this_date: Union[datetime.date, str, ForwardRef(None)] = None) ‑> datetime.date</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def this_date_or_last_trading_date(this_date: Union[date, str, None] = None) -&gt; date:
    if this_date is None:
        return get_last_trading_date()
    this_date = validate_date(this_date)
    if is_date_holiday(this_date) or is_date_weekend(this_date):
        return get_previous_business_date(this_date)
    if is_date_today(this_date):
        return last_close_date()
    return this_date</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>this_date: Optional[datetime.date] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a datetime formatted as 'YYYY-MM-DD'. If no date is provided, function will return today's formatted date.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string(this_date: Union[date, None] = None) -&gt; str:
    &#34;&#34;&#34; 
    Returns a datetime formatted as &#39;YYYY-MM-DD&#39;. If no date is provided, function will return today&#39;s formatted date.
    &#34;&#34;&#34;
    if this_date is None:
        return to_string(today())
    return datetime.datetime.strftime(this_date, DATE_FORMAT)</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.today"><code class="name flex">
<span>def <span class="ident">today</span></span>(<span>) ‑> datetime.date</span>
</code></dt>
<dd>
<div class="desc"><p>Returns today's date</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def today() -&gt; datetime.date:
    &#34;&#34;&#34;
    Returns today&#39;s date
    &#34;&#34;&#34;
    return datetime.date.today()</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.truncate_future_from_date"><code class="name flex">
<span>def <span class="ident">truncate_future_from_date</span></span>(<span>this_date: Union[datetime.date, str]) ‑> datetime.date</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def truncate_future_from_date(this_date: Union[date, str]) -&gt; datetime.date:
    this_date = validate_date(this_date)
    if is_future_date(this_date):
        return today()
    return this_date</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.validate_date"><code class="name flex">
<span>def <span class="ident">validate_date</span></span>(<span>this_date: Any) ‑> datetime.date</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_date(this_date: Any) -&gt; date:
    if isinstance(this_date, str):
        return parse(this_date)
    if not isinstance(this_date, date):
        raise ValueError(
            f&#39;{this_date} is neither date nor \&#39;{DATE_FORMAT}\&#39; formatted string&#39;)
    return this_date</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.validate_date_list"><code class="name flex">
<span>def <span class="ident">validate_date_list</span></span>(<span>dates: List[Union[datetime.date, str]]) ‑> Optional[List[datetime.date]]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="raises">Raises</h2>
<ol>
<li><strong>ValueError</strong>
If the supplied list of dates contains unexpected data types, this error will be thrown.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_date_list(dates: Union[List[Union[datetime.date, str]]]) -&gt; Union[List[datetime.date], None]:
    &#34;&#34;&#34;

    Raises
    ------
    1. **ValueError**
        If the supplied list of dates contains unexpected data types, this error will be thrown.

    &#34;&#34;&#34;
    verified_dates = []
    for this_date in dates:
        if isinstance(this_date, str):
            verified_dates.append(parse(this_date))
            continue
        if isinstance(this_date, datetime.date):
            verified_dates.append(this_date)
            continue
        raise ValueError(
            f&#39;{this_date} is neither date nor \&#39;{DATE_FORMAT}\&#39;formatted string&#39;)
    return verified_dates</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.validate_date_range"><code class="name flex">
<span>def <span class="ident">validate_date_range</span></span>(<span>start_date: Any, end_date: Any) ‑> Tuple[datetime.date, datetime.date]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_date_range(start_date: Any, end_date: Any) -&gt; Tuple[date, date]:
    if isinstance(start_date, str):
        start_date = parse(start_date)
    elif not isinstance(start_date, date):
        raise ValueError(
            f&#39;{start_date} is neither date nor \&#39;{DATE_FORMAT}\&#39; formatted string&#39;)
    if isinstance(end_date, str):
        end_date = parse(end_date)
    elif not isinstance(end_date, date):
        raise ValueError(
            f&#39;{end_date} is neither date nor \&#39;{DATE_FORMAT}\&#39; formatted string&#39;)
    return validate_order_of_dates(start_date, end_date)</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.validate_order_of_dates"><code class="name flex">
<span>def <span class="ident">validate_order_of_dates</span></span>(<span>start_date: datetime.date, end_date: datetime.date) ‑> Tuple[datetime.date, datetime.date]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the inputted dates as an tuple ordered from earliest to latest.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_order_of_dates(start_date: date, end_date: date) -&gt; Tuple[date, date]:
    &#34;&#34;&#34;
    Returns the inputted dates as an tuple ordered from earliest to latest.
    &#34;&#34;&#34;
    delta = (end_date - start_date).days
    if delta &lt; 0:
        return end_date, start_date
    return start_date, end_date</code></pre>
</details>
</dd>
<dt id="scrilla.util.dater.weekends_between"><code class="name flex">
<span>def <span class="ident">weekends_between</span></span>(<span>start_date: Union[datetime.date, str], end_date: Union[datetime.date, str]) ‑> List[int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weekends_between(start_date: Union[date, str], end_date: Union[date, str]) -&gt; List[int]:
    start_date, end_date = validate_date_range(start_date, end_date)
    dates = dates_between(start_date, end_date)
    return len([1 for day in dates if day.weekday() &gt; 4])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrilla.util" href="index.html">scrilla.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="scrilla.util.dater.business_dates_between" href="#scrilla.util.dater.business_dates_between">business_dates_between</a></code></li>
<li><code><a title="scrilla.util.dater.business_days_between" href="#scrilla.util.dater.business_days_between">business_days_between</a></code></li>
<li><code><a title="scrilla.util.dater.consecutive_trading_days" href="#scrilla.util.dater.consecutive_trading_days">consecutive_trading_days</a></code></li>
<li><code><a title="scrilla.util.dater.dates_between" href="#scrilla.util.dater.dates_between">dates_between</a></code></li>
<li><code><a title="scrilla.util.dater.days_between" href="#scrilla.util.dater.days_between">days_between</a></code></li>
<li><code><a title="scrilla.util.dater.decrement_date_by_business_days" href="#scrilla.util.dater.decrement_date_by_business_days">decrement_date_by_business_days</a></code></li>
<li><code><a title="scrilla.util.dater.decrement_date_by_days" href="#scrilla.util.dater.decrement_date_by_days">decrement_date_by_days</a></code></li>
<li><code><a title="scrilla.util.dater.format_date_range" href="#scrilla.util.dater.format_date_range">format_date_range</a></code></li>
<li><code><a title="scrilla.util.dater.get_holidays_between" href="#scrilla.util.dater.get_holidays_between">get_holidays_between</a></code></li>
<li><code><a title="scrilla.util.dater.get_last_trading_date" href="#scrilla.util.dater.get_last_trading_date">get_last_trading_date</a></code></li>
<li><code><a title="scrilla.util.dater.get_next_business_date" href="#scrilla.util.dater.get_next_business_date">get_next_business_date</a></code></li>
<li><code><a title="scrilla.util.dater.get_previous_business_date" href="#scrilla.util.dater.get_previous_business_date">get_previous_business_date</a></code></li>
<li><code><a title="scrilla.util.dater.get_time_to_next_month" href="#scrilla.util.dater.get_time_to_next_month">get_time_to_next_month</a></code></li>
<li><code><a title="scrilla.util.dater.get_time_to_next_period" href="#scrilla.util.dater.get_time_to_next_period">get_time_to_next_period</a></code></li>
<li><code><a title="scrilla.util.dater.get_time_to_next_quarter" href="#scrilla.util.dater.get_time_to_next_quarter">get_time_to_next_quarter</a></code></li>
<li><code><a title="scrilla.util.dater.get_time_to_next_year" href="#scrilla.util.dater.get_time_to_next_year">get_time_to_next_year</a></code></li>
<li><code><a title="scrilla.util.dater.increment_date_by_business_days" href="#scrilla.util.dater.increment_date_by_business_days">increment_date_by_business_days</a></code></li>
<li><code><a title="scrilla.util.dater.intersect_with_trading_dates" href="#scrilla.util.dater.intersect_with_trading_dates">intersect_with_trading_dates</a></code></li>
<li><code><a title="scrilla.util.dater.is_date_holiday" href="#scrilla.util.dater.is_date_holiday">is_date_holiday</a></code></li>
<li><code><a title="scrilla.util.dater.is_date_today" href="#scrilla.util.dater.is_date_today">is_date_today</a></code></li>
<li><code><a title="scrilla.util.dater.is_date_weekend" href="#scrilla.util.dater.is_date_weekend">is_date_weekend</a></code></li>
<li><code><a title="scrilla.util.dater.is_future_date" href="#scrilla.util.dater.is_future_date">is_future_date</a></code></li>
<li><code><a title="scrilla.util.dater.is_trading_date" href="#scrilla.util.dater.is_trading_date">is_trading_date</a></code></li>
<li><code><a title="scrilla.util.dater.last_close_date" href="#scrilla.util.dater.last_close_date">last_close_date</a></code></li>
<li><code><a title="scrilla.util.dater.parse" href="#scrilla.util.dater.parse">parse</a></code></li>
<li><code><a title="scrilla.util.dater.this_date_or_last_trading_date" href="#scrilla.util.dater.this_date_or_last_trading_date">this_date_or_last_trading_date</a></code></li>
<li><code><a title="scrilla.util.dater.to_string" href="#scrilla.util.dater.to_string">to_string</a></code></li>
<li><code><a title="scrilla.util.dater.today" href="#scrilla.util.dater.today">today</a></code></li>
<li><code><a title="scrilla.util.dater.truncate_future_from_date" href="#scrilla.util.dater.truncate_future_from_date">truncate_future_from_date</a></code></li>
<li><code><a title="scrilla.util.dater.validate_date" href="#scrilla.util.dater.validate_date">validate_date</a></code></li>
<li><code><a title="scrilla.util.dater.validate_date_list" href="#scrilla.util.dater.validate_date_list">validate_date_list</a></code></li>
<li><code><a title="scrilla.util.dater.validate_date_range" href="#scrilla.util.dater.validate_date_range">validate_date_range</a></code></li>
<li><code><a title="scrilla.util.dater.validate_order_of_dates" href="#scrilla.util.dater.validate_order_of_dates">validate_order_of_dates</a></code></li>
<li><code><a title="scrilla.util.dater.weekends_between" href="#scrilla.util.dater.weekends_between">weekends_between</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>