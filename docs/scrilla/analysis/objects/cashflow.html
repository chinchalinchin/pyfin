<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scrilla.analysis.objects.cashflow API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrilla.analysis.objects.cashflow</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of scrilla: https://github.com/chinchalinchin/scrilla.

# scrilla is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.

# scrilla is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with scrilla.  If not, see &lt;https://www.gnu.org/licenses/&gt;
# or &lt;https://github.com/chinchalinchin/scrilla/blob/develop/main/LICENSE&gt;.

import datetime

from scrilla import static, services, settings
from scrilla.util import helper, outputter
import scrilla.analysis.estimators as estimators

logger = outputter.Logger(&#39;analysis.objects.cashflow&#39;, settings.LOG_LEVEL)

# Technically these are periods
FREQ_DAY=1/365
FREQ_MONTH=1/12
FREQ_QUARTER=1/4
FREQ_ANNUAL=1

# Frequency = 1 / period
class Cashflow:
    &#34;&#34;&#34;
    Description
    -----------
    A class that represents a set of future cashflows. The class is initialized with the &#39;sample&#39; variable, a list of past cashflows and their dates, and a linear regression model is inferred from the sample. Alternatively, a `growth_function` can be provided that describes the cash flow as a function of time in years. If a `growth_function` is provided, the class skips the linear regression model. \n \n

    If the sample of data is not large enough to infer a linear regression model, the estimation model will default to simplge Martingale process where E(X2|X1) = X1, i.e. the next expected value given the current value is the current value, or put in plain english, without more information the best guess for the future value of an asset is its current value. \n \n

    The growth model, whether estimated or provided, is used to project the future value of cashflows and then these projections are discounted back to the present by the risk free rate. A discount rate different from the risk free rate can be specified by providing the constructor a value for discount_rate. \n \n

    Parameters
    ----------
    1. sample: list { &#39;date_1&#39; : &#39;value_1&#39;, &#39;date_2&#39;: &#39;value_2&#39;, ... } \n
        A list comprised of the cashflow\&#39;s historical values. The list must be ordered from latest to earliest, i.e. in descending order. \n \n
    2. period: float \n
        The period between the cash flow payments. Measured as the length of time between two distinct cash flows, assuming all such payments are evenly spaced across time. The value should be measured in years. If a period is not specified, then a period will be inferred from the sample of data by averaging the time periods between successive payments in the sample. Common period are statically accessible through `FREQ_DAY`, `FREQ_MONTH`, `FREQ_QUARTER` and `FREQ_ANNUAL`. (Yes, I know period = 1 / frequency; deal with it.) \n \n 
    3. growth_function: function \n
        A function that describes the cash flow as a function of time in years. If provided, the class will skip linear regression for estimating the cash flow model. If a `growth_function` is provided without a sample, a period must be specified. If a `growth_function` is provided with a sample and no period, the period will be inferred from the dates in the sample. If a `growth_function` is provided with a period, then the sample will be ignored altogether. \n \n
    4. discount_rate: float \n
        The rate of return used to discount future cash flows back to the present. If not provided, the `discount_rate` defaults to the risk free rate defined by the **RISK_FREE** environment variable. \n \n
    5. constant: float \n
        If the cashflow is constant with respect to time, specify the value of it with this argument. Will override `growth_function` and sample. If constant is specified, you MUST also specify a period or else you will encounter errors when trying to calculate the net present value of future cashflows. \n \n
    
    NOTES
    -----
    NOTE #1: A constant cashflow can be specified in three ways: 1. By passing in a constant amount through the constructor `constant` variable. 2. By passing in a constant function with respect to time through the constructor `growth_function` variable. 3. By passing in a dataset of length one through the constructor `sample` variable.  In any of the cases, you MUST pass in a period or the `net_present_value` method of this class will return False. \n \n

    NOTE #2: Both a growth_function and a sample of data can be passed in at once to this class. If doing so, the `growth_function` will take precedence and be used for calculations in the `net_present_value` method. The sample will be used to infer the length of a period between cashflows, unless a period is also specified. If a period is specified in addition to sample and `growth_function`, the period will take precedence over the period inferred from the sample of data. \n \n

    NOTE #3: In general, the Cashflow object must always be initialized in one of the following ways: \n
        1. Constructor args: (`sample`) -&gt; period inferred from sample, linear regression used for growth
        2. Constructor args: (`sample`, `period`) -&gt; period from constructor, linear regression used for growth
        3. Constructor args: (`sample`, `period`, `growth_function`) -&gt; period from constructor, `growth_function` used for growth, sample ignored
        4. Constructor args: (`sample`, `growth_function`) -&gt; period inferred from sample, `growth_function` used for growth
        5. Constructor args: (`period`, `growth_function`) -&gt; period from constructor, `growth_function` used for growth
        6. Constructor args: (`period`, `constant`) -&gt; period from constructor, constant used for growth
    TODOs
    -----
    1. Implement prediction interval function to get error bars for graphs and general usage.

    &#34;&#34;&#34;
    def __init__(self, sample=None, period=None, growth_function=None, constant=None, discount_rate=None, ):
        self.sample = sample
        self.period = period
        self.growth_function = growth_function

        # if constant is specified, override sample and growth_function
        if constant is not None:
            logger.debug(f&#39;constant = $ {constant}; period MUST NOT be null!&#39;)
            logger.debug(f&#39;period = {self.period}&#39;)
            self.constant = constant
            self.sample = None
            self.growth_function = None
        else:
            self.constant = None

        # If sample provided, use simple linear regression
        if self.sample is not None and self.growth_function is None:
            self.generate_time_series_for_sample()
            self.regress_growth_function()
        
        if discount_rate is None:
            self.discount_rate = services.get_risk_free_rate()
        else:
            self.discount_rate = discount_rate

        logger.debug(f&#39;Using discount_rate = {self.discount_rate}&#39;)

        # If no frequency is specified, infer frequency from sample
        if self.sample is not None and self.period is None:
            self.infer_period()

        if self.sample is not None and len(self.sample) &gt; 0:
            self.time_to_today = self.calculate_time_to_today()

    def infer_period(self):
        logger.debug(&#39;Attempting to infer period/frequency of cashflows.&#39;)

        # no_of_dates = len - 1 because delta is being computed, i.e.
        #   lose one date.
        dates, no_of_dates = self.sample.keys(), (len(self.sample.keys()) - 1)
        first_pass = True
        mean_delta = 0

        if no_of_dates &lt; 2:
            logger.debug(&#39;Cannot infer period from sample size less than or equal to 1&#39;)
            self.period = None
            self.frequency = None

        else:
            for date in dates:
                if first_pass:
                    tomorrows_date = helper.parse_date_string(date)
                    first_pass = False

                else:
                    todays_date = helper.parse_date_string(date)
                    delta = (tomorrows_date - todays_date).days / 365
                    mean_delta += delta / no_of_dates 
                    tomorrows_date = todays_date

            self.period =  mean_delta
            self.frequency = 1 / self.period 
            logger.debug(f&#39;Inferred period = {self.period} yrs&#39;)
            logger.debug(f&#39;Inferred frequency = {self.frequency}&#39;)

    def generate_time_series_for_sample(self):
        self.time_series = []

        dates, no_of_dates = self.sample.keys(), len(self.sample.keys())

        if no_of_dates == 0:
            logger.debug(&#39;Cannot generate a time series for a sample size of 0.&#39;)
            self.time_series = None
        else:
            first_date = helper.parse_date_string(list(dates)[-1])

            for date in dates:
                this_date = helper.parse_date_string(date)
                delta = (this_date - first_date).days
                time_in_years = delta / 365
                self.time_series.append(time_in_years)
    
    def calculate_time_to_today(self):
        first_date = helper.parse_date_string(list(self.sample.keys())[-1])
        today = datetime.date.today()
        return ((today - first_date).days/365)
        

    def regress_growth_function(self):
        to_array = [ self.sample[date] for date in self.sample ]

        self.beta = estimators.simple_regression_beta(x=self.time_series, y=to_array)
        self.alpha = estimators.simple_regression_alpha(x=self.time_series, y=to_array)
        
        if not self.beta or not self.alpha:
            if len(self.sample) &gt; 0:
                self.alpha = list(self.sample.items())[0][1]
                logger.debug(&#39;Error calculating regression coefficients; Defaulting to Markovian process E(X2|X1) = X1.&#39;)
                logger.debug(f&#39;Estimation model : y = {self.alpha}&#39;)
            else: 
                logger.debug(&#39;Not enough information to formulate estimation model.&#39;)
        else:
            logger.debug(f&#39;Linear regression model : y = {self.beta} * x + {self.alpha}&#39;)

    def generate_model_series(self):
        return [self.alpha + self.beta*time for time in self.time_series]

    def generate_model_comparison(self):
        model_prices= self.generate_model_series()

        return[ { &#39;date&#39;: date, 
                  &#39;model_price&#39;: model_prices[index], 
                  &#39;actual_price&#39;: self.sample[date] } 
                for index, date in enumerate(self.sample.keys()) ]
        
    def get_growth_function(self, x):
        if self.growth_function is None:
            if self.constant is not None:
                return self.constant
            return (self.alpha + self.beta*(x + self.time_to_today))
        return self.growth_function(x)

    # TODO: use trading days or actual days?
    def calculate_net_present_value(self):
    
        if self.period is None:
            logger.debug(&#39;No period detected for cashflows. Not enough information to calculate net present value.&#39;)
            return False
        
        time_to_first_payment = 0
        if self.period == FREQ_ANNUAL:
            time_to_first_payment = helper.get_time_to_next_year()
            
        elif self.period == FREQ_QUARTER:
            time_to_first_payment = helper.get_time_to_next_quarter()

        elif self.period == FREQ_MONTH:
            time_to_first_payment = helper.get_time_to_next_month()

        elif self.period == FREQ_DAY:
            time_to_first_payment = FREQ_DAY
        
        else:
            dates = self.sample.keys()
            latest_date = helper.parse_date_string(list(dates)[0])
            time_to_first_payment = helper.get_time_to_next_period(starting_date=latest_date, period=self.period)

        self.NPV, i, current_time = 0, 0, 0
        calculating = True
        while calculating: 
            previous_value = self.NPV

            if self.period is not None:
                current_time = time_to_first_payment + i * self.period
            else:
                logger.debug(&#39;Not enough information to calculate net present value of cash flow.&#39;)
                return False
            
            self.NPV += self.get_growth_function(current_time) / ((1 + self.discount_rate)**current_time)

            if self.NPV - previous_value &lt; static.constants[&#39;NPV_DELTA_TOLERANCE&#39;]:
                calculating = False
            i += 1

        return self.NPV
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrilla.analysis.objects.cashflow.Cashflow"><code class="flex name class">
<span>class <span class="ident">Cashflow</span></span>
<span>(</span><span>sample=None, period=None, growth_function=None, constant=None, discount_rate=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>A class that represents a set of future cashflows. The class is initialized with the 'sample' variable, a list of past cashflows and their dates, and a linear regression model is inferred from the sample. Alternatively, a <code>growth_function</code> can be provided that describes the cash flow as a function of time in years. If a <code>growth_function</code> is provided, the class skips the linear regression model. </p>
<p>If the sample of data is not large enough to infer a linear regression model, the estimation model will default to simplge Martingale process where E(X2|X1) = X1, i.e. the next expected value given the current value is the current value, or put in plain english, without more information the best guess for the future value of an asset is its current value. </p>
<p>The growth model, whether estimated or provided, is used to project the future value of cashflows and then these projections are discounted back to the present by the risk free rate. A discount rate different from the risk free rate can be specified by providing the constructor a value for discount_rate. </p>
<h2 id="parameters">Parameters</h2>
<ol>
<li>
<p>sample: list { 'date_1' : 'value_1', 'date_2': 'value_2', &hellip; } </p>
<p>A list comprised of the cashflow's historical values. The list must be ordered from latest to earliest, i.e. in descending order. </p>
</li>
<li>
<p>period: float </p>
<p>The period between the cash flow payments. Measured as the length of time between two distinct cash flows, assuming all such payments are evenly spaced across time. The value should be measured in years. If a period is not specified, then a period will be inferred from the sample of data by averaging the time periods between successive payments in the sample. Common period are statically accessible through <code>FREQ_DAY</code>, <code>FREQ_MONTH</code>, <code>FREQ_QUARTER</code> and <code>FREQ_ANNUAL</code>. (Yes, I know period = 1 / frequency; deal with it.) </p>
</li>
<li>
<p>growth_function: function </p>
<p>A function that describes the cash flow as a function of time in years. If provided, the class will skip linear regression for estimating the cash flow model. If a <code>growth_function</code> is provided without a sample, a period must be specified. If a <code>growth_function</code> is provided with a sample and no period, the period will be inferred from the dates in the sample. If a <code>growth_function</code> is provided with a period, then the sample will be ignored altogether. </p>
</li>
<li>
<p>discount_rate: float </p>
<p>The rate of return used to discount future cash flows back to the present. If not provided, the <code>discount_rate</code> defaults to the risk free rate defined by the <strong>RISK_FREE</strong> environment variable. </p>
</li>
<li>
<p>constant: float </p>
<p>If the cashflow is constant with respect to time, specify the value of it with this argument. Will override <code>growth_function</code> and sample. If constant is specified, you MUST also specify a period or else you will encounter errors when trying to calculate the net present value of future cashflows. </p>
</li>
</ol>
<h2 id="notes">Notes</h2>
<p>NOTE #1: A constant cashflow can be specified in three ways: 1. By passing in a constant amount through the constructor <code>constant</code> variable. 2. By passing in a constant function with respect to time through the constructor <code>growth_function</code> variable. 3. By passing in a dataset of length one through the constructor <code>sample</code> variable.
In any of the cases, you MUST pass in a period or the <code>net_present_value</code> method of this class will return False. </p>
<p>NOTE #2: Both a growth_function and a sample of data can be passed in at once to this class. If doing so, the <code>growth_function</code> will take precedence and be used for calculations in the <code>net_present_value</code> method. The sample will be used to infer the length of a period between cashflows, unless a period is also specified. If a period is specified in addition to sample and <code>growth_function</code>, the period will take precedence over the period inferred from the sample of data. </p>
<p>NOTE #3: In general, the Cashflow object must always be initialized in one of the following ways: </p>
<pre><code>1. Constructor args: (&lt;code&gt;sample&lt;/code&gt;) -&gt; period inferred from sample, linear regression used for growth
2. Constructor args: (&lt;code&gt;sample&lt;/code&gt;, &lt;code&gt;period&lt;/code&gt;) -&gt; period from constructor, linear regression used for growth
3. Constructor args: (&lt;code&gt;sample&lt;/code&gt;, &lt;code&gt;period&lt;/code&gt;, &lt;code&gt;growth\_function&lt;/code&gt;) -&gt; period from constructor, &lt;code&gt;growth\_function&lt;/code&gt; used for growth, sample ignored
4. Constructor args: (&lt;code&gt;sample&lt;/code&gt;, &lt;code&gt;growth\_function&lt;/code&gt;) -&gt; period inferred from sample, &lt;code&gt;growth\_function&lt;/code&gt; used for growth
5. Constructor args: (&lt;code&gt;period&lt;/code&gt;, &lt;code&gt;growth\_function&lt;/code&gt;) -&gt; period from constructor, &lt;code&gt;growth\_function&lt;/code&gt; used for growth
6. Constructor args: (&lt;code&gt;period&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;) -&gt; period from constructor, constant used for growth
</code></pre>
<h2 id="todos">Todos</h2>
<ol>
<li>Implement prediction interval function to get error bars for graphs and general usage.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cashflow:
    &#34;&#34;&#34;
    Description
    -----------
    A class that represents a set of future cashflows. The class is initialized with the &#39;sample&#39; variable, a list of past cashflows and their dates, and a linear regression model is inferred from the sample. Alternatively, a `growth_function` can be provided that describes the cash flow as a function of time in years. If a `growth_function` is provided, the class skips the linear regression model. \n \n

    If the sample of data is not large enough to infer a linear regression model, the estimation model will default to simplge Martingale process where E(X2|X1) = X1, i.e. the next expected value given the current value is the current value, or put in plain english, without more information the best guess for the future value of an asset is its current value. \n \n

    The growth model, whether estimated or provided, is used to project the future value of cashflows and then these projections are discounted back to the present by the risk free rate. A discount rate different from the risk free rate can be specified by providing the constructor a value for discount_rate. \n \n

    Parameters
    ----------
    1. sample: list { &#39;date_1&#39; : &#39;value_1&#39;, &#39;date_2&#39;: &#39;value_2&#39;, ... } \n
        A list comprised of the cashflow\&#39;s historical values. The list must be ordered from latest to earliest, i.e. in descending order. \n \n
    2. period: float \n
        The period between the cash flow payments. Measured as the length of time between two distinct cash flows, assuming all such payments are evenly spaced across time. The value should be measured in years. If a period is not specified, then a period will be inferred from the sample of data by averaging the time periods between successive payments in the sample. Common period are statically accessible through `FREQ_DAY`, `FREQ_MONTH`, `FREQ_QUARTER` and `FREQ_ANNUAL`. (Yes, I know period = 1 / frequency; deal with it.) \n \n 
    3. growth_function: function \n
        A function that describes the cash flow as a function of time in years. If provided, the class will skip linear regression for estimating the cash flow model. If a `growth_function` is provided without a sample, a period must be specified. If a `growth_function` is provided with a sample and no period, the period will be inferred from the dates in the sample. If a `growth_function` is provided with a period, then the sample will be ignored altogether. \n \n
    4. discount_rate: float \n
        The rate of return used to discount future cash flows back to the present. If not provided, the `discount_rate` defaults to the risk free rate defined by the **RISK_FREE** environment variable. \n \n
    5. constant: float \n
        If the cashflow is constant with respect to time, specify the value of it with this argument. Will override `growth_function` and sample. If constant is specified, you MUST also specify a period or else you will encounter errors when trying to calculate the net present value of future cashflows. \n \n
    
    NOTES
    -----
    NOTE #1: A constant cashflow can be specified in three ways: 1. By passing in a constant amount through the constructor `constant` variable. 2. By passing in a constant function with respect to time through the constructor `growth_function` variable. 3. By passing in a dataset of length one through the constructor `sample` variable.  In any of the cases, you MUST pass in a period or the `net_present_value` method of this class will return False. \n \n

    NOTE #2: Both a growth_function and a sample of data can be passed in at once to this class. If doing so, the `growth_function` will take precedence and be used for calculations in the `net_present_value` method. The sample will be used to infer the length of a period between cashflows, unless a period is also specified. If a period is specified in addition to sample and `growth_function`, the period will take precedence over the period inferred from the sample of data. \n \n

    NOTE #3: In general, the Cashflow object must always be initialized in one of the following ways: \n
        1. Constructor args: (`sample`) -&gt; period inferred from sample, linear regression used for growth
        2. Constructor args: (`sample`, `period`) -&gt; period from constructor, linear regression used for growth
        3. Constructor args: (`sample`, `period`, `growth_function`) -&gt; period from constructor, `growth_function` used for growth, sample ignored
        4. Constructor args: (`sample`, `growth_function`) -&gt; period inferred from sample, `growth_function` used for growth
        5. Constructor args: (`period`, `growth_function`) -&gt; period from constructor, `growth_function` used for growth
        6. Constructor args: (`period`, `constant`) -&gt; period from constructor, constant used for growth
    TODOs
    -----
    1. Implement prediction interval function to get error bars for graphs and general usage.

    &#34;&#34;&#34;
    def __init__(self, sample=None, period=None, growth_function=None, constant=None, discount_rate=None, ):
        self.sample = sample
        self.period = period
        self.growth_function = growth_function

        # if constant is specified, override sample and growth_function
        if constant is not None:
            logger.debug(f&#39;constant = $ {constant}; period MUST NOT be null!&#39;)
            logger.debug(f&#39;period = {self.period}&#39;)
            self.constant = constant
            self.sample = None
            self.growth_function = None
        else:
            self.constant = None

        # If sample provided, use simple linear regression
        if self.sample is not None and self.growth_function is None:
            self.generate_time_series_for_sample()
            self.regress_growth_function()
        
        if discount_rate is None:
            self.discount_rate = services.get_risk_free_rate()
        else:
            self.discount_rate = discount_rate

        logger.debug(f&#39;Using discount_rate = {self.discount_rate}&#39;)

        # If no frequency is specified, infer frequency from sample
        if self.sample is not None and self.period is None:
            self.infer_period()

        if self.sample is not None and len(self.sample) &gt; 0:
            self.time_to_today = self.calculate_time_to_today()

    def infer_period(self):
        logger.debug(&#39;Attempting to infer period/frequency of cashflows.&#39;)

        # no_of_dates = len - 1 because delta is being computed, i.e.
        #   lose one date.
        dates, no_of_dates = self.sample.keys(), (len(self.sample.keys()) - 1)
        first_pass = True
        mean_delta = 0

        if no_of_dates &lt; 2:
            logger.debug(&#39;Cannot infer period from sample size less than or equal to 1&#39;)
            self.period = None
            self.frequency = None

        else:
            for date in dates:
                if first_pass:
                    tomorrows_date = helper.parse_date_string(date)
                    first_pass = False

                else:
                    todays_date = helper.parse_date_string(date)
                    delta = (tomorrows_date - todays_date).days / 365
                    mean_delta += delta / no_of_dates 
                    tomorrows_date = todays_date

            self.period =  mean_delta
            self.frequency = 1 / self.period 
            logger.debug(f&#39;Inferred period = {self.period} yrs&#39;)
            logger.debug(f&#39;Inferred frequency = {self.frequency}&#39;)

    def generate_time_series_for_sample(self):
        self.time_series = []

        dates, no_of_dates = self.sample.keys(), len(self.sample.keys())

        if no_of_dates == 0:
            logger.debug(&#39;Cannot generate a time series for a sample size of 0.&#39;)
            self.time_series = None
        else:
            first_date = helper.parse_date_string(list(dates)[-1])

            for date in dates:
                this_date = helper.parse_date_string(date)
                delta = (this_date - first_date).days
                time_in_years = delta / 365
                self.time_series.append(time_in_years)
    
    def calculate_time_to_today(self):
        first_date = helper.parse_date_string(list(self.sample.keys())[-1])
        today = datetime.date.today()
        return ((today - first_date).days/365)
        

    def regress_growth_function(self):
        to_array = [ self.sample[date] for date in self.sample ]

        self.beta = estimators.simple_regression_beta(x=self.time_series, y=to_array)
        self.alpha = estimators.simple_regression_alpha(x=self.time_series, y=to_array)
        
        if not self.beta or not self.alpha:
            if len(self.sample) &gt; 0:
                self.alpha = list(self.sample.items())[0][1]
                logger.debug(&#39;Error calculating regression coefficients; Defaulting to Markovian process E(X2|X1) = X1.&#39;)
                logger.debug(f&#39;Estimation model : y = {self.alpha}&#39;)
            else: 
                logger.debug(&#39;Not enough information to formulate estimation model.&#39;)
        else:
            logger.debug(f&#39;Linear regression model : y = {self.beta} * x + {self.alpha}&#39;)

    def generate_model_series(self):
        return [self.alpha + self.beta*time for time in self.time_series]

    def generate_model_comparison(self):
        model_prices= self.generate_model_series()

        return[ { &#39;date&#39;: date, 
                  &#39;model_price&#39;: model_prices[index], 
                  &#39;actual_price&#39;: self.sample[date] } 
                for index, date in enumerate(self.sample.keys()) ]
        
    def get_growth_function(self, x):
        if self.growth_function is None:
            if self.constant is not None:
                return self.constant
            return (self.alpha + self.beta*(x + self.time_to_today))
        return self.growth_function(x)

    # TODO: use trading days or actual days?
    def calculate_net_present_value(self):
    
        if self.period is None:
            logger.debug(&#39;No period detected for cashflows. Not enough information to calculate net present value.&#39;)
            return False
        
        time_to_first_payment = 0
        if self.period == FREQ_ANNUAL:
            time_to_first_payment = helper.get_time_to_next_year()
            
        elif self.period == FREQ_QUARTER:
            time_to_first_payment = helper.get_time_to_next_quarter()

        elif self.period == FREQ_MONTH:
            time_to_first_payment = helper.get_time_to_next_month()

        elif self.period == FREQ_DAY:
            time_to_first_payment = FREQ_DAY
        
        else:
            dates = self.sample.keys()
            latest_date = helper.parse_date_string(list(dates)[0])
            time_to_first_payment = helper.get_time_to_next_period(starting_date=latest_date, period=self.period)

        self.NPV, i, current_time = 0, 0, 0
        calculating = True
        while calculating: 
            previous_value = self.NPV

            if self.period is not None:
                current_time = time_to_first_payment + i * self.period
            else:
                logger.debug(&#39;Not enough information to calculate net present value of cash flow.&#39;)
                return False
            
            self.NPV += self.get_growth_function(current_time) / ((1 + self.discount_rate)**current_time)

            if self.NPV - previous_value &lt; static.constants[&#39;NPV_DELTA_TOLERANCE&#39;]:
                calculating = False
            i += 1

        return self.NPV</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="scrilla.analysis.objects.cashflow.Cashflow.calculate_net_present_value"><code class="name flex">
<span>def <span class="ident">calculate_net_present_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_net_present_value(self):

    if self.period is None:
        logger.debug(&#39;No period detected for cashflows. Not enough information to calculate net present value.&#39;)
        return False
    
    time_to_first_payment = 0
    if self.period == FREQ_ANNUAL:
        time_to_first_payment = helper.get_time_to_next_year()
        
    elif self.period == FREQ_QUARTER:
        time_to_first_payment = helper.get_time_to_next_quarter()

    elif self.period == FREQ_MONTH:
        time_to_first_payment = helper.get_time_to_next_month()

    elif self.period == FREQ_DAY:
        time_to_first_payment = FREQ_DAY
    
    else:
        dates = self.sample.keys()
        latest_date = helper.parse_date_string(list(dates)[0])
        time_to_first_payment = helper.get_time_to_next_period(starting_date=latest_date, period=self.period)

    self.NPV, i, current_time = 0, 0, 0
    calculating = True
    while calculating: 
        previous_value = self.NPV

        if self.period is not None:
            current_time = time_to_first_payment + i * self.period
        else:
            logger.debug(&#39;Not enough information to calculate net present value of cash flow.&#39;)
            return False
        
        self.NPV += self.get_growth_function(current_time) / ((1 + self.discount_rate)**current_time)

        if self.NPV - previous_value &lt; static.constants[&#39;NPV_DELTA_TOLERANCE&#39;]:
            calculating = False
        i += 1

    return self.NPV</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.objects.cashflow.Cashflow.calculate_time_to_today"><code class="name flex">
<span>def <span class="ident">calculate_time_to_today</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_time_to_today(self):
    first_date = helper.parse_date_string(list(self.sample.keys())[-1])
    today = datetime.date.today()
    return ((today - first_date).days/365)</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.objects.cashflow.Cashflow.generate_model_comparison"><code class="name flex">
<span>def <span class="ident">generate_model_comparison</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_model_comparison(self):
    model_prices= self.generate_model_series()

    return[ { &#39;date&#39;: date, 
              &#39;model_price&#39;: model_prices[index], 
              &#39;actual_price&#39;: self.sample[date] } 
            for index, date in enumerate(self.sample.keys()) ]</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.objects.cashflow.Cashflow.generate_model_series"><code class="name flex">
<span>def <span class="ident">generate_model_series</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_model_series(self):
    return [self.alpha + self.beta*time for time in self.time_series]</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.objects.cashflow.Cashflow.generate_time_series_for_sample"><code class="name flex">
<span>def <span class="ident">generate_time_series_for_sample</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_time_series_for_sample(self):
    self.time_series = []

    dates, no_of_dates = self.sample.keys(), len(self.sample.keys())

    if no_of_dates == 0:
        logger.debug(&#39;Cannot generate a time series for a sample size of 0.&#39;)
        self.time_series = None
    else:
        first_date = helper.parse_date_string(list(dates)[-1])

        for date in dates:
            this_date = helper.parse_date_string(date)
            delta = (this_date - first_date).days
            time_in_years = delta / 365
            self.time_series.append(time_in_years)</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.objects.cashflow.Cashflow.get_growth_function"><code class="name flex">
<span>def <span class="ident">get_growth_function</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_growth_function(self, x):
    if self.growth_function is None:
        if self.constant is not None:
            return self.constant
        return (self.alpha + self.beta*(x + self.time_to_today))
    return self.growth_function(x)</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.objects.cashflow.Cashflow.infer_period"><code class="name flex">
<span>def <span class="ident">infer_period</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def infer_period(self):
    logger.debug(&#39;Attempting to infer period/frequency of cashflows.&#39;)

    # no_of_dates = len - 1 because delta is being computed, i.e.
    #   lose one date.
    dates, no_of_dates = self.sample.keys(), (len(self.sample.keys()) - 1)
    first_pass = True
    mean_delta = 0

    if no_of_dates &lt; 2:
        logger.debug(&#39;Cannot infer period from sample size less than or equal to 1&#39;)
        self.period = None
        self.frequency = None

    else:
        for date in dates:
            if first_pass:
                tomorrows_date = helper.parse_date_string(date)
                first_pass = False

            else:
                todays_date = helper.parse_date_string(date)
                delta = (tomorrows_date - todays_date).days / 365
                mean_delta += delta / no_of_dates 
                tomorrows_date = todays_date

        self.period =  mean_delta
        self.frequency = 1 / self.period 
        logger.debug(f&#39;Inferred period = {self.period} yrs&#39;)
        logger.debug(f&#39;Inferred frequency = {self.frequency}&#39;)</code></pre>
</details>
</dd>
<dt id="scrilla.analysis.objects.cashflow.Cashflow.regress_growth_function"><code class="name flex">
<span>def <span class="ident">regress_growth_function</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regress_growth_function(self):
    to_array = [ self.sample[date] for date in self.sample ]

    self.beta = estimators.simple_regression_beta(x=self.time_series, y=to_array)
    self.alpha = estimators.simple_regression_alpha(x=self.time_series, y=to_array)
    
    if not self.beta or not self.alpha:
        if len(self.sample) &gt; 0:
            self.alpha = list(self.sample.items())[0][1]
            logger.debug(&#39;Error calculating regression coefficients; Defaulting to Markovian process E(X2|X1) = X1.&#39;)
            logger.debug(f&#39;Estimation model : y = {self.alpha}&#39;)
        else: 
            logger.debug(&#39;Not enough information to formulate estimation model.&#39;)
    else:
        logger.debug(f&#39;Linear regression model : y = {self.beta} * x + {self.alpha}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrilla.analysis.objects" href="index.html">scrilla.analysis.objects</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrilla.analysis.objects.cashflow.Cashflow" href="#scrilla.analysis.objects.cashflow.Cashflow">Cashflow</a></code></h4>
<ul class="">
<li><code><a title="scrilla.analysis.objects.cashflow.Cashflow.calculate_net_present_value" href="#scrilla.analysis.objects.cashflow.Cashflow.calculate_net_present_value">calculate_net_present_value</a></code></li>
<li><code><a title="scrilla.analysis.objects.cashflow.Cashflow.calculate_time_to_today" href="#scrilla.analysis.objects.cashflow.Cashflow.calculate_time_to_today">calculate_time_to_today</a></code></li>
<li><code><a title="scrilla.analysis.objects.cashflow.Cashflow.generate_model_comparison" href="#scrilla.analysis.objects.cashflow.Cashflow.generate_model_comparison">generate_model_comparison</a></code></li>
<li><code><a title="scrilla.analysis.objects.cashflow.Cashflow.generate_model_series" href="#scrilla.analysis.objects.cashflow.Cashflow.generate_model_series">generate_model_series</a></code></li>
<li><code><a title="scrilla.analysis.objects.cashflow.Cashflow.generate_time_series_for_sample" href="#scrilla.analysis.objects.cashflow.Cashflow.generate_time_series_for_sample">generate_time_series_for_sample</a></code></li>
<li><code><a title="scrilla.analysis.objects.cashflow.Cashflow.get_growth_function" href="#scrilla.analysis.objects.cashflow.Cashflow.get_growth_function">get_growth_function</a></code></li>
<li><code><a title="scrilla.analysis.objects.cashflow.Cashflow.infer_period" href="#scrilla.analysis.objects.cashflow.Cashflow.infer_period">infer_period</a></code></li>
<li><code><a title="scrilla.analysis.objects.cashflow.Cashflow.regress_growth_function" href="#scrilla.analysis.objects.cashflow.Cashflow.regress_growth_function">regress_growth_function</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>