<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>scrilla.cache API documentation</title>
<meta name="description" content="This module provides a data access layer for a SQLite database maintained on the local file system on the location set by the environment variable â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrilla.cache</code></h1>
</header>
<section id="section-intro">
<p>This module provides a data access layer for a SQLite database maintained on the local file system on the location set by the environment variable <strong>SQLITE_FILE</strong>. If this environment variable is not set, the file location defaults to the <em>installation_directory</em>/data/cache/scrilla.db. The database caches asset prices, statistical calculations and interest rates. This allows the program to avoid excessive API calls to external services for calculations that involve the same quantity. For instance, to calculate correlation, the mean and variance of the individual assets must be calculated over the price history of each before the correlation is calculated over their combined price history; this involves four references to a sample of prices, at different points in the program which do not necessarily share scope with the location of the other calculations, so they can not share the in-memory version of the prices. </p>
<p>In addition to preventing excessive API calls, the cache prevents redundant calculations. For example, calculating the market beta for a series of assets requires the variance of the market proxy for each calculation. Rather than recalculate this quantity each time, the program will defer to the values stored in the cache.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file is part of scrilla: https://github.com/chinchalinchin/scrilla.

# scrilla is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.

# scrilla is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with scrilla.  If not, see &lt;https://www.gnu.org/licenses/&gt;
# or &lt;https://github.com/chinchalinchin/scrilla/blob/develop/main/LICENSE&gt;.

&#34;&#34;&#34;
This module provides a data access layer for a SQLite database maintained on the local file system on the location set by the environment variable **SQLITE_FILE**. If this environment variable is not set, the file location defaults to the *installation_directory*/data/cache/scrilla.db. The database caches asset prices, statistical calculations and interest rates. This allows the program to avoid excessive API calls to external services for calculations that involve the same quantity. For instance, to calculate correlation, the mean and variance of the individual assets must be calculated over the price history of each before the correlation is calculated over their combined price history; this involves four references to a sample of prices, at different points in the program which do not necessarily share scope with the location of the other calculations, so they can not share the in-memory version of the prices. 

In addition to preventing excessive API calls, the cache prevents redundant calculations. For example, calculating the market beta for a series of assets requires the variance of the market proxy for each calculation. Rather than recalculate this quantity each time, the program will defer to the values stored in the cache.
&#34;&#34;&#34;
import sqlite3

from scrilla import settings, static
from scrilla.util import outputter

logger = outputter.Logger(&#34;cache&#34;, settings.LOG_LEVEL)

class Cache():
    &#34;&#34;&#34;
    Methods
    -------

    1. execute_transaction

        Parameters
        ----------
        1. transactions: str\n
            Statement to be executed and committed. \n \n
        2. formatter: dict
            Dictionary of parameters used to format statement. Statements are formatted with DB-API&#39;s name substitution. See sqlite3 documentation for more information:https://docs.python.org/3/library/sqlite3.html.  \n \n
    
    2. query_database

        Parameters
        ----------
        1. query : str\n
            Query to be exectued.
        2. formatter: dict
            Dictionary of parameters used to format statement. Statements are formatted with DB-API&#39;s name substitution. See sqlite3 documentation for more information:https://docs.python.org/3/library/sqlite3.html.  \n \n

    &#34;&#34;&#34;

    def __init__(self, table_transaction):
        self.execute_transaction(table_transaction)

    @staticmethod
    def execute_transaction(transaction, formatter=None):
        con = sqlite3.connect(settings.CACHE_SQLITE_FILE)
        executor =  con.cursor()
        if formatter is not None:
            executor.execute(transaction, formatter)
        else:
            executor.execute(transaction)
        con.commit()
        con.close()

    @staticmethod
    def execute_query(query, formatter=None):
        con = sqlite3.connect(settings.CACHE_SQLITE_FILE)
        con.row_factory = sqlite3.Row
        executor = con.cursor()
        if formatter is not None:
            return executor.execute(query, formatter).fetchall()
        return executor.execute(query).fetchall()

class PriceCache(Cache):
    create_table_transaction=&#34;CREATE TABLE IF NOT EXISTS prices (ticker text, date text, open real, close real, UNIQUE(ticker, date))&#34;
    insert_row_transaction=&#34;INSERT OR IGNORE INTO prices (ticker, date, open, close) VALUES (:ticker, :date, :open, :close)&#34;
    price_query=&#34;SELECT date, open, close from prices WHERE ticker = :ticker AND date &lt;= date(:end_date) AND date &gt;= date(:start_date) ORDER BY date(date) DESC&#34;

    def __init__(self):
        super().__init__(PriceCache.create_table_transaction)

    @staticmethod
    def to_dict(query_results):
        return { result[0]: { static.keys[&#39;PRICES&#39;][&#39;OPEN&#39;]: result[1], static.keys[&#39;PRICES&#39;][&#39;CLOSE&#39;]: result[2] } for result in query_results }

    def save_row(self, ticker, date, open_price, close_price):
        logger.verbose(F&#39;Attempting to insert {ticker} prices on {date} to cache&#39;)
        formatter = { &#39;ticker&#39;: ticker, &#39;date&#39;: date, &#39;open&#39;: open_price, &#39;close&#39;: close_price}
        self.execute_transaction(transaction=PriceCache.insert_row_transaction, formatter=formatter)

    def filter_price_cache(self, ticker, start_date, end_date):
        logger.debug(f&#39;Querying SQLite cache \n\t{PriceCache.price_query}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}&#39;)
        formatter = { &#39;ticker&#39;: ticker, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date}
        results = self.execute_query(query=PriceCache.price_query, formatter=formatter)

        if len(results)&gt;0:
            logger.debug(f&#39;Found {ticker} prices in the cache&#39;)
            return self.to_dict(results)
        logger.debug(f&#39;No results found for {ticker} prices in the cache&#39;)
        return None

class InterestCache(Cache):
    create_table_transaction=&#34;CREATE TABLE IF NOT EXISTS interest(maturity text, date text, value real, UNIQUE(maturity, date))&#34;
    insert_row_transaction=&#34;INSERT OR IGNORE INTO interest (maturity, date, value) VALUES (:maturity, :date, :value)&#34;
    stat_query=&#34;SELECT date, value FROM interest WHERE maturity=:maturity AND date &lt;=date(:end_date) AND date&gt;=date(:start_date) ORDER BY date(date) DESC&#34;

    def __init__(self):
        super().__init__(InterestCache.create_table_transaction)

    @staticmethod
    def to_dict(query_results):
        return { result[0]: result[1] for result in query_results }

    def save_row(self, date, value):
        for index, maturity in enumerate(static.keys[&#39;YIELD_CURVE&#39;]):
            logger.verbose(f&#39;Saving {maturity} yield on {date} to cache&#39;)
            formatter = { &#39;maturity&#39;: maturity, &#39;date&#39;: date, &#39;value&#39;: value[index] }
            self.execute_transaction(transaction=InterestCache.insert_row_transaction, formatter=formatter)
    
    def filter_interest_cache(self, maturity, start_date, end_date):
        logger.debug(f&#39;Querying SQLite cache \n\t{InterestCache.stat_query}\n\t\t with :maturity={maturity}, :start_date={start_date}, :end_date={end_date}&#39;)
        formatter = { &#39;maturity&#39;: maturity, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date }
        results = self.execute_query(query=InterestCache.stat_query, formatter=formatter)

        if len(results)&gt;0:
            logger.debug(f&#39;Found {maturity} yield on in the cache&#39;)
            return self.to_dict(results)
        logger.debug(f&#39;No results found for {maturity} yield in cache&#39;)
        return None

# NOTE: do not need to order `correlation_query` and `profile_query` because profiles and correlations are uniquely 
#       determined by the (`start_date`, `end_date`, &#39;ticker_1&#39;, &#39;ticker_2&#39;)-tuple. More or less. There is a bit of 
#       fuzziness, since the permutation of the previous tuple, (&#39;start_date&#39;, &#39;end_date&#39;, &#39;ticker_2&#39;, &#39;ticker_1&#39;), 
#       will also be associated with the same correlation value. No other mappings between a date&#39;s correlation value
#       and the correlation&#39;s tickers are possible though. In other words, the query, for a given 
#       (ticker_1, ticker_2)-permutation will only ever return one result.
class CorrelationCache(Cache):
    create_table_transaction=&#34;CREATE TABLE IF NOT EXISTS correlations (ticker_1 TEXT, ticker_2 TEXT, start_date TEXT, end_date TEXT, correlation REAL, method TEXT)&#34;
    insert_row_transaction=&#34;INSERT INTO correlations (ticker_1, ticker_2, start_date, end_date, correlation, method) VALUES (:ticker_1, :ticker_2, :start_date, :end_date, :correlation, :method)&#34;
    correlation_query=&#34;SELECT correlation FROM correlations WHERE ticker_1=:ticker_1 AND ticker_2=:ticker_2 AND start_date=date(:start_date) AND end_date=date(:end_date) AND method=:method&#34;

    def __init__(self):
        super().__init__(CorrelationCache.create_table_transaction)
    
    @staticmethod
    def to_dict(query_results):
        return { static.keys[&#39;STATISTICS&#39;][&#39;CORRELATION&#39;]: query_results[0][0] }

    def save_row(self, ticker_1, ticker_2, start_date, end_date, correlation, method = settings.ESTIMATION_METHOD):
        logger.verbose(f&#39;Saving ({ticker_1}, {ticker_2}) correlation from {start_date} to {end_date} to the cacche&#39;)
        formatter_1 = { &#39;ticker_1&#39;: ticker_1, &#39;ticker_2&#39;: ticker_2, &#39;method&#39;: method,
                        &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;correlation&#39;: correlation}
        formatter_2 = { &#39;ticker_1&#39;: ticker_2, &#39;ticker_2&#39;: ticker_1, &#39;method&#39;: method,
                        &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;correlation&#39;: correlation}
        self.execute_transaction(transaction=CorrelationCache.insert_row_transaction, formatter=formatter_1)
        self.execute_transaction(transaction=CorrelationCache.insert_row_transaction, formatter=formatter_2)
    
    def filter_correlation_cache(self, ticker_1, ticker_2, start_date, end_date, method = settings.ESTIMATION_METHOD):
        formatter_1 = { &#39;ticker_1&#39;: ticker_1, &#39;ticker_2&#39;: ticker_2, &#39;method&#39;: method,
                        &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date}
        formatter_2 = { &#39;ticker_1&#39;: ticker_2, &#39;ticker_2&#39;: ticker_1, &#39;method&#39;: method,
                        &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date}
        
        logger.debug(f&#39;Querying SQLite cache \n\t{CorrelationCache.correlation_query}\n\t\t with :ticker_1={ticker_1}, :ticker_2={ticker_2}&#39;)
        results = self.execute_query(query=CorrelationCache.correlation_query, formatter=formatter_1)
        if len(results)&gt;0:
            logger.debug(f&#39;Found ({ticker_1},{ticker_2}) correlation in the cache&#39;)
            return self.to_dict(results)
        results = self.execute_query(query=CorrelationCache.correlation_query, formatter=formatter_2)
        if len(results)&gt;0:
            logger.debug(f&#39;Found ({ticker_1},{ticker_2}) correlation in the cache&#39;)
            return self.to_dict(results)
        logger.debug(f&#39;No results found for ({ticker_1}, {ticker_2}) correlation in the cache&#39;)
        return None

class ProfileCache(Cache):
    create_table_transaction=&#34;CREATE TABLE IF NOT EXISTS profile (id INTEGER PRIMARY KEY, ticker TEXT, start_date TEXT, end_date TEXT, annual_return REAL, annual_volatility REAL, sharpe_ratio REAL, asset_beta REAL, equity_cost REAL, method TEXT)&#34;
    
    query_filter=&#34;ticker=:ticker AND start_date=date(:start_date) AND end_date=date(:end_date) AND :method=method&#34;
    identity_query=&#34;(SELECT id FROM profile WHERE ticker=:ticker AND start_date=:start_date AND end_date=:end_date AND :method=method)&#34;
    value_args=&#34;(id, ticker, start_date, end_date, annual_return, annual_volatility, sharpe_ratio, asset_beta, equity_cost, method)&#34;

    return_query=&#34;(SELECT annual_return FROM profile WHERE {query_filter})&#34;.format(query_filter=query_filter)
    vol_query=&#34;(SELECT annual_volatility FROM profile WHERE {query_filter})&#34;.format(query_filter=query_filter)
    sharpe_query=&#34;(SELECT sharpe_ratio FROM profile WHERE {query_filter})&#34;.format(query_filter=query_filter)
    beta_query=&#34;(SELECT asset_beta FROM profile WHERE {query_filter})&#34;.format(query_filter=query_filter)
    equity_query=&#34;(SELECT equity_cost FROM profile WHERE {query_filter})&#34;.format(query_filter=query_filter)

    update_return_transaction=&#34;INSERT or REPLACE INTO profile {value_args} VALUES ({identity_query}, :ticker, :start_date, :end_date, :annual_return, {vol_query}, {sharpe_query}, {beta_query}, {equity_query}, :method)&#34;.format(
                                identity_query=identity_query, value_args=value_args, vol_query=vol_query, sharpe_query=sharpe_query, beta_query=beta_query, equity_query=equity_query)
    update_vol_transaction=&#34;INSERT or REPLACE INTO profile {value_args} VALUES ({identity_query}, :ticker, :start_date, :end_date, {return_query}, :annual_volatility, {sharpe_query}, {beta_query}, {equity_query}, :method)&#34;.format(
                                identity_query=identity_query, value_args=value_args, return_query=return_query, sharpe_query=sharpe_query, beta_query=beta_query, equity_query=equity_query)
    update_sharpe_transaction=&#34;INSERT or REPLACE INTO profile {value_args} VALUES ({identity_query}, :ticker, :start_date, :end_date, {return_query}, {vol_query}, :sharpe_ratio, {beta_query}, {equity_query}, :method)&#34;.format(
                                identity_query=identity_query, value_args=value_args, return_query=return_query, vol_query=vol_query, beta_query=beta_query, equity_query=equity_query)
    update_beta_transaction=&#34;INSERT or REPLACE INTO profile {value_args} VALUES ({identity_query}, :ticker, :start_date, :end_date, {return_query}, {vol_query}, {sharpe_query}, :asset_beta, {equity_query}, :method)&#34;.format(
                                identity_query=identity_query, value_args=value_args, return_query=return_query, vol_query=vol_query, sharpe_query=sharpe_query, equity_query=equity_query)
    update_equity_tranasction=&#34;INSERT or REPLACE INTO profile {value_args} VALUES ({identity_query}, :ticker, :start_date, :end_date, {return_query}, {vol_query}, {sharpe_query}, {beta_query}, :equity_cost, :method)&#34;.format(
                                identity_query=identity_query, value_args=value_args, return_query=return_query, vol_query=vol_query, sharpe_query=sharpe_query, beta_query=beta_query)

    profile_query=&#34;SELECT ifnull(annual_return, &#39;empty&#39;), ifnull(annual_volatility, &#39;empty&#39;), ifnull(sharpe_ratio, &#39;empty&#39;), ifnull(asset_beta, &#39;empty&#39;), ifnull(equity_cost, &#39;empty&#39;) FROM profile WHERE {query_filter}&#34;.format(query_filter=query_filter)

    def __init__(self):
        super().__init__(ProfileCache.create_table_transaction)

    @staticmethod
    def to_dict(query_result):
        return {  static.keys[&#39;STATISTICS&#39;][&#39;RETURN&#39;] : query_result[0][0] if query_result[0][0] != &#39;empty&#39; else None, 
                  static.keys[&#39;STATISTICS&#39;][&#39;VOLATILITY&#39;] : query_result[0][1] if query_result[0][1] != &#39;empty&#39; else None,
                  static.keys[&#39;STATISTICS&#39;][&#39;SHARPE&#39;] : query_result[0][2] if query_result[0][2] != &#39;empty&#39; else None,
                  static.keys[&#39;STATISTICS&#39;][&#39;BETA&#39;] : query_result[0][3] if query_result[0][3] != &#39;empty&#39; else None,
                  static.keys[&#39;STATISTICS&#39;][&#39;EQUITY&#39;] : query_result[0][4] if query_result[0][4] != &#39;empty&#39; else None }

    def save_or_update_row(self, ticker, start_date, end_date, annual_return=None, annual_volatility=None, sharpe_ratio=None, asset_beta=None, equity_cost=None, method=settings.ESTIMATION_METHOD):
        formatter = { &#39;ticker&#39;: ticker, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;method&#39;: method}
        
        if annual_return is not None:
            logger.verbose(f&#39;Updating SQLite cache... \n\t{ProfileCache.update_return_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :annual_return={annual_return}&#39;)
            formatter[&#39;annual_return&#39;] = annual_return
            self.execute_transaction(transaction=ProfileCache.update_return_transaction, formatter=formatter)
        if annual_volatility is not None:
            logger.verbose(f&#39;Updating SQLite cache... \n\t{ProfileCache.update_vol_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :annual_volatility={annual_volatility}&#39;)
            formatter[&#39;annual_volatility&#39;] = annual_volatility
            self.execute_transaction(transaction=ProfileCache.update_vol_transaction, formatter=formatter)        
        if sharpe_ratio is not None:
            logger.verbose(f&#39;Updating SQLite cache... \n\t{ProfileCache.update_sharpe_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :sharpe_ratio={sharpe_ratio}&#39;)
            formatter[&#39;sharpe_ratio&#39;] = sharpe_ratio
            self.execute_transaction(transaction=ProfileCache.update_sharpe_transaction, formatter=formatter)
        if asset_beta is not None:
            logger.verbose(f&#39;Updating SQLite cache \n\t{ProfileCache.update_beta_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :asset_beta={asset_beta}&#39;)
            formatter[&#39;asset_beta&#39;] = asset_beta
            self.execute_transaction(transaction=ProfileCache.update_beta_transaction, formatter=formatter)
        if equity_cost is not None:
            logger.verbose(f&#39;Updating SQLite cache \n\t{ProfileCache.update_return_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :equity_cost={equity_cost}&#39;)
            formatter[&#39;equity_cost&#39;] = equity_cost
            self.execute_transaction(transaction=ProfileCache.update_equity_tranasction, formatter=formatter)

    def filter_profile_cache(self, ticker, start_date, end_date, method = settings.ESTIMATION_METHOD):
        logger.debug(f&#39;Querying SQLite cache: \n\t{ProfileCache.profile_query}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}&#39;) 
        formatter = { &#39;ticker&#39;: ticker, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;method&#39;: method }
        result = self.execute_query(query=ProfileCache.profile_query, formatter=formatter)

        if len(result)&gt;0:
            logger.debug(f&#39;{ticker} profile found in cache&#39;)
            return self.to_dict(result)
        logger.debug(f&#39;No results found for {ticker} profile in the cache&#39;)
        return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrilla.cache.Cache"><code class="flex name class">
<span>class <span class="ident">Cache</span></span>
<span>(</span><span>table_transaction)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="methods">Methods</h2>
<ol>
<li>
<p>execute_transaction</p>
<h2 id="parameters">Parameters</h2>
<ol>
<li>
<p>transactions: str</p>
<p>Statement to be executed and committed. </p>
</li>
<li>
<p>formatter: dict
Dictionary of parameters used to format statement. Statements are formatted with DB-API's name substitution. See sqlite3 documentation for more information:<a href="https://docs.python.org/3/library/sqlite3.html.">https://docs.python.org/3/library/sqlite3.html.</a>
</p>
</li>
</ol>
</li>
<li>
<p>query_database</p>
<h2 id="parameters_1">Parameters</h2>
<ol>
<li>
<p>query : str</p>
<p>Query to be exectued.
2. formatter: dict
Dictionary of parameters used to format statement. Statements are formatted with DB-API's name substitution. See sqlite3 documentation for more information:<a href="https://docs.python.org/3/library/sqlite3.html.">https://docs.python.org/3/library/sqlite3.html.</a></p>
</li>
</ol>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cache():
    &#34;&#34;&#34;
    Methods
    -------

    1. execute_transaction

        Parameters
        ----------
        1. transactions: str\n
            Statement to be executed and committed. \n \n
        2. formatter: dict
            Dictionary of parameters used to format statement. Statements are formatted with DB-API&#39;s name substitution. See sqlite3 documentation for more information:https://docs.python.org/3/library/sqlite3.html.  \n \n
    
    2. query_database

        Parameters
        ----------
        1. query : str\n
            Query to be exectued.
        2. formatter: dict
            Dictionary of parameters used to format statement. Statements are formatted with DB-API&#39;s name substitution. See sqlite3 documentation for more information:https://docs.python.org/3/library/sqlite3.html.  \n \n

    &#34;&#34;&#34;

    def __init__(self, table_transaction):
        self.execute_transaction(table_transaction)

    @staticmethod
    def execute_transaction(transaction, formatter=None):
        con = sqlite3.connect(settings.CACHE_SQLITE_FILE)
        executor =  con.cursor()
        if formatter is not None:
            executor.execute(transaction, formatter)
        else:
            executor.execute(transaction)
        con.commit()
        con.close()

    @staticmethod
    def execute_query(query, formatter=None):
        con = sqlite3.connect(settings.CACHE_SQLITE_FILE)
        con.row_factory = sqlite3.Row
        executor = con.cursor()
        if formatter is not None:
            return executor.execute(query, formatter).fetchall()
        return executor.execute(query).fetchall()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrilla.cache.CorrelationCache" href="#scrilla.cache.CorrelationCache">CorrelationCache</a></li>
<li><a title="scrilla.cache.InterestCache" href="#scrilla.cache.InterestCache">InterestCache</a></li>
<li><a title="scrilla.cache.PriceCache" href="#scrilla.cache.PriceCache">PriceCache</a></li>
<li><a title="scrilla.cache.ProfileCache" href="#scrilla.cache.ProfileCache">ProfileCache</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="scrilla.cache.Cache.execute_query"><code class="name flex">
<span>def <span class="ident">execute_query</span></span>(<span>query, formatter=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def execute_query(query, formatter=None):
    con = sqlite3.connect(settings.CACHE_SQLITE_FILE)
    con.row_factory = sqlite3.Row
    executor = con.cursor()
    if formatter is not None:
        return executor.execute(query, formatter).fetchall()
    return executor.execute(query).fetchall()</code></pre>
</details>
</dd>
<dt id="scrilla.cache.Cache.execute_transaction"><code class="name flex">
<span>def <span class="ident">execute_transaction</span></span>(<span>transaction, formatter=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def execute_transaction(transaction, formatter=None):
    con = sqlite3.connect(settings.CACHE_SQLITE_FILE)
    executor =  con.cursor()
    if formatter is not None:
        executor.execute(transaction, formatter)
    else:
        executor.execute(transaction)
    con.commit()
    con.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrilla.cache.CorrelationCache"><code class="flex name class">
<span>class <span class="ident">CorrelationCache</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="methods">Methods</h2>
<ol>
<li>
<p>execute_transaction</p>
<h2 id="parameters">Parameters</h2>
<ol>
<li>
<p>transactions: str</p>
<p>Statement to be executed and committed. </p>
</li>
<li>
<p>formatter: dict
Dictionary of parameters used to format statement. Statements are formatted with DB-API's name substitution. See sqlite3 documentation for more information:<a href="https://docs.python.org/3/library/sqlite3.html.">https://docs.python.org/3/library/sqlite3.html.</a>
</p>
</li>
</ol>
</li>
<li>
<p>query_database</p>
<h2 id="parameters_1">Parameters</h2>
<ol>
<li>
<p>query : str</p>
<p>Query to be exectued.
2. formatter: dict
Dictionary of parameters used to format statement. Statements are formatted with DB-API's name substitution. See sqlite3 documentation for more information:<a href="https://docs.python.org/3/library/sqlite3.html.">https://docs.python.org/3/library/sqlite3.html.</a></p>
</li>
</ol>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CorrelationCache(Cache):
    create_table_transaction=&#34;CREATE TABLE IF NOT EXISTS correlations (ticker_1 TEXT, ticker_2 TEXT, start_date TEXT, end_date TEXT, correlation REAL, method TEXT)&#34;
    insert_row_transaction=&#34;INSERT INTO correlations (ticker_1, ticker_2, start_date, end_date, correlation, method) VALUES (:ticker_1, :ticker_2, :start_date, :end_date, :correlation, :method)&#34;
    correlation_query=&#34;SELECT correlation FROM correlations WHERE ticker_1=:ticker_1 AND ticker_2=:ticker_2 AND start_date=date(:start_date) AND end_date=date(:end_date) AND method=:method&#34;

    def __init__(self):
        super().__init__(CorrelationCache.create_table_transaction)
    
    @staticmethod
    def to_dict(query_results):
        return { static.keys[&#39;STATISTICS&#39;][&#39;CORRELATION&#39;]: query_results[0][0] }

    def save_row(self, ticker_1, ticker_2, start_date, end_date, correlation, method = settings.ESTIMATION_METHOD):
        logger.verbose(f&#39;Saving ({ticker_1}, {ticker_2}) correlation from {start_date} to {end_date} to the cacche&#39;)
        formatter_1 = { &#39;ticker_1&#39;: ticker_1, &#39;ticker_2&#39;: ticker_2, &#39;method&#39;: method,
                        &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;correlation&#39;: correlation}
        formatter_2 = { &#39;ticker_1&#39;: ticker_2, &#39;ticker_2&#39;: ticker_1, &#39;method&#39;: method,
                        &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;correlation&#39;: correlation}
        self.execute_transaction(transaction=CorrelationCache.insert_row_transaction, formatter=formatter_1)
        self.execute_transaction(transaction=CorrelationCache.insert_row_transaction, formatter=formatter_2)
    
    def filter_correlation_cache(self, ticker_1, ticker_2, start_date, end_date, method = settings.ESTIMATION_METHOD):
        formatter_1 = { &#39;ticker_1&#39;: ticker_1, &#39;ticker_2&#39;: ticker_2, &#39;method&#39;: method,
                        &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date}
        formatter_2 = { &#39;ticker_1&#39;: ticker_2, &#39;ticker_2&#39;: ticker_1, &#39;method&#39;: method,
                        &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date}
        
        logger.debug(f&#39;Querying SQLite cache \n\t{CorrelationCache.correlation_query}\n\t\t with :ticker_1={ticker_1}, :ticker_2={ticker_2}&#39;)
        results = self.execute_query(query=CorrelationCache.correlation_query, formatter=formatter_1)
        if len(results)&gt;0:
            logger.debug(f&#39;Found ({ticker_1},{ticker_2}) correlation in the cache&#39;)
            return self.to_dict(results)
        results = self.execute_query(query=CorrelationCache.correlation_query, formatter=formatter_2)
        if len(results)&gt;0:
            logger.debug(f&#39;Found ({ticker_1},{ticker_2}) correlation in the cache&#39;)
            return self.to_dict(results)
        logger.debug(f&#39;No results found for ({ticker_1}, {ticker_2}) correlation in the cache&#39;)
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrilla.cache.Cache" href="#scrilla.cache.Cache">Cache</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrilla.cache.CorrelationCache.correlation_query"><code class="name">var <span class="ident">correlation_query</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.CorrelationCache.create_table_transaction"><code class="name">var <span class="ident">create_table_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.CorrelationCache.insert_row_transaction"><code class="name">var <span class="ident">insert_row_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="scrilla.cache.CorrelationCache.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>query_results)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_dict(query_results):
    return { static.keys[&#39;STATISTICS&#39;][&#39;CORRELATION&#39;]: query_results[0][0] }</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrilla.cache.CorrelationCache.filter_correlation_cache"><code class="name flex">
<span>def <span class="ident">filter_correlation_cache</span></span>(<span>self, ticker_1, ticker_2, start_date, end_date, method='moments')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_correlation_cache(self, ticker_1, ticker_2, start_date, end_date, method = settings.ESTIMATION_METHOD):
    formatter_1 = { &#39;ticker_1&#39;: ticker_1, &#39;ticker_2&#39;: ticker_2, &#39;method&#39;: method,
                    &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date}
    formatter_2 = { &#39;ticker_1&#39;: ticker_2, &#39;ticker_2&#39;: ticker_1, &#39;method&#39;: method,
                    &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date}
    
    logger.debug(f&#39;Querying SQLite cache \n\t{CorrelationCache.correlation_query}\n\t\t with :ticker_1={ticker_1}, :ticker_2={ticker_2}&#39;)
    results = self.execute_query(query=CorrelationCache.correlation_query, formatter=formatter_1)
    if len(results)&gt;0:
        logger.debug(f&#39;Found ({ticker_1},{ticker_2}) correlation in the cache&#39;)
        return self.to_dict(results)
    results = self.execute_query(query=CorrelationCache.correlation_query, formatter=formatter_2)
    if len(results)&gt;0:
        logger.debug(f&#39;Found ({ticker_1},{ticker_2}) correlation in the cache&#39;)
        return self.to_dict(results)
    logger.debug(f&#39;No results found for ({ticker_1}, {ticker_2}) correlation in the cache&#39;)
    return None</code></pre>
</details>
</dd>
<dt id="scrilla.cache.CorrelationCache.save_row"><code class="name flex">
<span>def <span class="ident">save_row</span></span>(<span>self, ticker_1, ticker_2, start_date, end_date, correlation, method='moments')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_row(self, ticker_1, ticker_2, start_date, end_date, correlation, method = settings.ESTIMATION_METHOD):
    logger.verbose(f&#39;Saving ({ticker_1}, {ticker_2}) correlation from {start_date} to {end_date} to the cacche&#39;)
    formatter_1 = { &#39;ticker_1&#39;: ticker_1, &#39;ticker_2&#39;: ticker_2, &#39;method&#39;: method,
                    &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;correlation&#39;: correlation}
    formatter_2 = { &#39;ticker_1&#39;: ticker_2, &#39;ticker_2&#39;: ticker_1, &#39;method&#39;: method,
                    &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;correlation&#39;: correlation}
    self.execute_transaction(transaction=CorrelationCache.insert_row_transaction, formatter=formatter_1)
    self.execute_transaction(transaction=CorrelationCache.insert_row_transaction, formatter=formatter_2)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrilla.cache.InterestCache"><code class="flex name class">
<span>class <span class="ident">InterestCache</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="methods">Methods</h2>
<ol>
<li>
<p>execute_transaction</p>
<h2 id="parameters">Parameters</h2>
<ol>
<li>
<p>transactions: str</p>
<p>Statement to be executed and committed. </p>
</li>
<li>
<p>formatter: dict
Dictionary of parameters used to format statement. Statements are formatted with DB-API's name substitution. See sqlite3 documentation for more information:<a href="https://docs.python.org/3/library/sqlite3.html.">https://docs.python.org/3/library/sqlite3.html.</a>
</p>
</li>
</ol>
</li>
<li>
<p>query_database</p>
<h2 id="parameters_1">Parameters</h2>
<ol>
<li>
<p>query : str</p>
<p>Query to be exectued.
2. formatter: dict
Dictionary of parameters used to format statement. Statements are formatted with DB-API's name substitution. See sqlite3 documentation for more information:<a href="https://docs.python.org/3/library/sqlite3.html.">https://docs.python.org/3/library/sqlite3.html.</a></p>
</li>
</ol>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InterestCache(Cache):
    create_table_transaction=&#34;CREATE TABLE IF NOT EXISTS interest(maturity text, date text, value real, UNIQUE(maturity, date))&#34;
    insert_row_transaction=&#34;INSERT OR IGNORE INTO interest (maturity, date, value) VALUES (:maturity, :date, :value)&#34;
    stat_query=&#34;SELECT date, value FROM interest WHERE maturity=:maturity AND date &lt;=date(:end_date) AND date&gt;=date(:start_date) ORDER BY date(date) DESC&#34;

    def __init__(self):
        super().__init__(InterestCache.create_table_transaction)

    @staticmethod
    def to_dict(query_results):
        return { result[0]: result[1] for result in query_results }

    def save_row(self, date, value):
        for index, maturity in enumerate(static.keys[&#39;YIELD_CURVE&#39;]):
            logger.verbose(f&#39;Saving {maturity} yield on {date} to cache&#39;)
            formatter = { &#39;maturity&#39;: maturity, &#39;date&#39;: date, &#39;value&#39;: value[index] }
            self.execute_transaction(transaction=InterestCache.insert_row_transaction, formatter=formatter)
    
    def filter_interest_cache(self, maturity, start_date, end_date):
        logger.debug(f&#39;Querying SQLite cache \n\t{InterestCache.stat_query}\n\t\t with :maturity={maturity}, :start_date={start_date}, :end_date={end_date}&#39;)
        formatter = { &#39;maturity&#39;: maturity, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date }
        results = self.execute_query(query=InterestCache.stat_query, formatter=formatter)

        if len(results)&gt;0:
            logger.debug(f&#39;Found {maturity} yield on in the cache&#39;)
            return self.to_dict(results)
        logger.debug(f&#39;No results found for {maturity} yield in cache&#39;)
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrilla.cache.Cache" href="#scrilla.cache.Cache">Cache</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrilla.cache.InterestCache.create_table_transaction"><code class="name">var <span class="ident">create_table_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.InterestCache.insert_row_transaction"><code class="name">var <span class="ident">insert_row_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.InterestCache.stat_query"><code class="name">var <span class="ident">stat_query</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="scrilla.cache.InterestCache.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>query_results)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_dict(query_results):
    return { result[0]: result[1] for result in query_results }</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrilla.cache.InterestCache.filter_interest_cache"><code class="name flex">
<span>def <span class="ident">filter_interest_cache</span></span>(<span>self, maturity, start_date, end_date)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_interest_cache(self, maturity, start_date, end_date):
    logger.debug(f&#39;Querying SQLite cache \n\t{InterestCache.stat_query}\n\t\t with :maturity={maturity}, :start_date={start_date}, :end_date={end_date}&#39;)
    formatter = { &#39;maturity&#39;: maturity, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date }
    results = self.execute_query(query=InterestCache.stat_query, formatter=formatter)

    if len(results)&gt;0:
        logger.debug(f&#39;Found {maturity} yield on in the cache&#39;)
        return self.to_dict(results)
    logger.debug(f&#39;No results found for {maturity} yield in cache&#39;)
    return None</code></pre>
</details>
</dd>
<dt id="scrilla.cache.InterestCache.save_row"><code class="name flex">
<span>def <span class="ident">save_row</span></span>(<span>self, date, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_row(self, date, value):
    for index, maturity in enumerate(static.keys[&#39;YIELD_CURVE&#39;]):
        logger.verbose(f&#39;Saving {maturity} yield on {date} to cache&#39;)
        formatter = { &#39;maturity&#39;: maturity, &#39;date&#39;: date, &#39;value&#39;: value[index] }
        self.execute_transaction(transaction=InterestCache.insert_row_transaction, formatter=formatter)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrilla.cache.PriceCache"><code class="flex name class">
<span>class <span class="ident">PriceCache</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="methods">Methods</h2>
<ol>
<li>
<p>execute_transaction</p>
<h2 id="parameters">Parameters</h2>
<ol>
<li>
<p>transactions: str</p>
<p>Statement to be executed and committed. </p>
</li>
<li>
<p>formatter: dict
Dictionary of parameters used to format statement. Statements are formatted with DB-API's name substitution. See sqlite3 documentation for more information:<a href="https://docs.python.org/3/library/sqlite3.html.">https://docs.python.org/3/library/sqlite3.html.</a>
</p>
</li>
</ol>
</li>
<li>
<p>query_database</p>
<h2 id="parameters_1">Parameters</h2>
<ol>
<li>
<p>query : str</p>
<p>Query to be exectued.
2. formatter: dict
Dictionary of parameters used to format statement. Statements are formatted with DB-API's name substitution. See sqlite3 documentation for more information:<a href="https://docs.python.org/3/library/sqlite3.html.">https://docs.python.org/3/library/sqlite3.html.</a></p>
</li>
</ol>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PriceCache(Cache):
    create_table_transaction=&#34;CREATE TABLE IF NOT EXISTS prices (ticker text, date text, open real, close real, UNIQUE(ticker, date))&#34;
    insert_row_transaction=&#34;INSERT OR IGNORE INTO prices (ticker, date, open, close) VALUES (:ticker, :date, :open, :close)&#34;
    price_query=&#34;SELECT date, open, close from prices WHERE ticker = :ticker AND date &lt;= date(:end_date) AND date &gt;= date(:start_date) ORDER BY date(date) DESC&#34;

    def __init__(self):
        super().__init__(PriceCache.create_table_transaction)

    @staticmethod
    def to_dict(query_results):
        return { result[0]: { static.keys[&#39;PRICES&#39;][&#39;OPEN&#39;]: result[1], static.keys[&#39;PRICES&#39;][&#39;CLOSE&#39;]: result[2] } for result in query_results }

    def save_row(self, ticker, date, open_price, close_price):
        logger.verbose(F&#39;Attempting to insert {ticker} prices on {date} to cache&#39;)
        formatter = { &#39;ticker&#39;: ticker, &#39;date&#39;: date, &#39;open&#39;: open_price, &#39;close&#39;: close_price}
        self.execute_transaction(transaction=PriceCache.insert_row_transaction, formatter=formatter)

    def filter_price_cache(self, ticker, start_date, end_date):
        logger.debug(f&#39;Querying SQLite cache \n\t{PriceCache.price_query}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}&#39;)
        formatter = { &#39;ticker&#39;: ticker, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date}
        results = self.execute_query(query=PriceCache.price_query, formatter=formatter)

        if len(results)&gt;0:
            logger.debug(f&#39;Found {ticker} prices in the cache&#39;)
            return self.to_dict(results)
        logger.debug(f&#39;No results found for {ticker} prices in the cache&#39;)
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrilla.cache.Cache" href="#scrilla.cache.Cache">Cache</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrilla.cache.PriceCache.create_table_transaction"><code class="name">var <span class="ident">create_table_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.PriceCache.insert_row_transaction"><code class="name">var <span class="ident">insert_row_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.PriceCache.price_query"><code class="name">var <span class="ident">price_query</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="scrilla.cache.PriceCache.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>query_results)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_dict(query_results):
    return { result[0]: { static.keys[&#39;PRICES&#39;][&#39;OPEN&#39;]: result[1], static.keys[&#39;PRICES&#39;][&#39;CLOSE&#39;]: result[2] } for result in query_results }</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrilla.cache.PriceCache.filter_price_cache"><code class="name flex">
<span>def <span class="ident">filter_price_cache</span></span>(<span>self, ticker, start_date, end_date)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_price_cache(self, ticker, start_date, end_date):
    logger.debug(f&#39;Querying SQLite cache \n\t{PriceCache.price_query}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}&#39;)
    formatter = { &#39;ticker&#39;: ticker, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date}
    results = self.execute_query(query=PriceCache.price_query, formatter=formatter)

    if len(results)&gt;0:
        logger.debug(f&#39;Found {ticker} prices in the cache&#39;)
        return self.to_dict(results)
    logger.debug(f&#39;No results found for {ticker} prices in the cache&#39;)
    return None</code></pre>
</details>
</dd>
<dt id="scrilla.cache.PriceCache.save_row"><code class="name flex">
<span>def <span class="ident">save_row</span></span>(<span>self, ticker, date, open_price, close_price)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_row(self, ticker, date, open_price, close_price):
    logger.verbose(F&#39;Attempting to insert {ticker} prices on {date} to cache&#39;)
    formatter = { &#39;ticker&#39;: ticker, &#39;date&#39;: date, &#39;open&#39;: open_price, &#39;close&#39;: close_price}
    self.execute_transaction(transaction=PriceCache.insert_row_transaction, formatter=formatter)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrilla.cache.ProfileCache"><code class="flex name class">
<span>class <span class="ident">ProfileCache</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="methods">Methods</h2>
<ol>
<li>
<p>execute_transaction</p>
<h2 id="parameters">Parameters</h2>
<ol>
<li>
<p>transactions: str</p>
<p>Statement to be executed and committed. </p>
</li>
<li>
<p>formatter: dict
Dictionary of parameters used to format statement. Statements are formatted with DB-API's name substitution. See sqlite3 documentation for more information:<a href="https://docs.python.org/3/library/sqlite3.html.">https://docs.python.org/3/library/sqlite3.html.</a>
</p>
</li>
</ol>
</li>
<li>
<p>query_database</p>
<h2 id="parameters_1">Parameters</h2>
<ol>
<li>
<p>query : str</p>
<p>Query to be exectued.
2. formatter: dict
Dictionary of parameters used to format statement. Statements are formatted with DB-API's name substitution. See sqlite3 documentation for more information:<a href="https://docs.python.org/3/library/sqlite3.html.">https://docs.python.org/3/library/sqlite3.html.</a></p>
</li>
</ol>
</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProfileCache(Cache):
    create_table_transaction=&#34;CREATE TABLE IF NOT EXISTS profile (id INTEGER PRIMARY KEY, ticker TEXT, start_date TEXT, end_date TEXT, annual_return REAL, annual_volatility REAL, sharpe_ratio REAL, asset_beta REAL, equity_cost REAL, method TEXT)&#34;
    
    query_filter=&#34;ticker=:ticker AND start_date=date(:start_date) AND end_date=date(:end_date) AND :method=method&#34;
    identity_query=&#34;(SELECT id FROM profile WHERE ticker=:ticker AND start_date=:start_date AND end_date=:end_date AND :method=method)&#34;
    value_args=&#34;(id, ticker, start_date, end_date, annual_return, annual_volatility, sharpe_ratio, asset_beta, equity_cost, method)&#34;

    return_query=&#34;(SELECT annual_return FROM profile WHERE {query_filter})&#34;.format(query_filter=query_filter)
    vol_query=&#34;(SELECT annual_volatility FROM profile WHERE {query_filter})&#34;.format(query_filter=query_filter)
    sharpe_query=&#34;(SELECT sharpe_ratio FROM profile WHERE {query_filter})&#34;.format(query_filter=query_filter)
    beta_query=&#34;(SELECT asset_beta FROM profile WHERE {query_filter})&#34;.format(query_filter=query_filter)
    equity_query=&#34;(SELECT equity_cost FROM profile WHERE {query_filter})&#34;.format(query_filter=query_filter)

    update_return_transaction=&#34;INSERT or REPLACE INTO profile {value_args} VALUES ({identity_query}, :ticker, :start_date, :end_date, :annual_return, {vol_query}, {sharpe_query}, {beta_query}, {equity_query}, :method)&#34;.format(
                                identity_query=identity_query, value_args=value_args, vol_query=vol_query, sharpe_query=sharpe_query, beta_query=beta_query, equity_query=equity_query)
    update_vol_transaction=&#34;INSERT or REPLACE INTO profile {value_args} VALUES ({identity_query}, :ticker, :start_date, :end_date, {return_query}, :annual_volatility, {sharpe_query}, {beta_query}, {equity_query}, :method)&#34;.format(
                                identity_query=identity_query, value_args=value_args, return_query=return_query, sharpe_query=sharpe_query, beta_query=beta_query, equity_query=equity_query)
    update_sharpe_transaction=&#34;INSERT or REPLACE INTO profile {value_args} VALUES ({identity_query}, :ticker, :start_date, :end_date, {return_query}, {vol_query}, :sharpe_ratio, {beta_query}, {equity_query}, :method)&#34;.format(
                                identity_query=identity_query, value_args=value_args, return_query=return_query, vol_query=vol_query, beta_query=beta_query, equity_query=equity_query)
    update_beta_transaction=&#34;INSERT or REPLACE INTO profile {value_args} VALUES ({identity_query}, :ticker, :start_date, :end_date, {return_query}, {vol_query}, {sharpe_query}, :asset_beta, {equity_query}, :method)&#34;.format(
                                identity_query=identity_query, value_args=value_args, return_query=return_query, vol_query=vol_query, sharpe_query=sharpe_query, equity_query=equity_query)
    update_equity_tranasction=&#34;INSERT or REPLACE INTO profile {value_args} VALUES ({identity_query}, :ticker, :start_date, :end_date, {return_query}, {vol_query}, {sharpe_query}, {beta_query}, :equity_cost, :method)&#34;.format(
                                identity_query=identity_query, value_args=value_args, return_query=return_query, vol_query=vol_query, sharpe_query=sharpe_query, beta_query=beta_query)

    profile_query=&#34;SELECT ifnull(annual_return, &#39;empty&#39;), ifnull(annual_volatility, &#39;empty&#39;), ifnull(sharpe_ratio, &#39;empty&#39;), ifnull(asset_beta, &#39;empty&#39;), ifnull(equity_cost, &#39;empty&#39;) FROM profile WHERE {query_filter}&#34;.format(query_filter=query_filter)

    def __init__(self):
        super().__init__(ProfileCache.create_table_transaction)

    @staticmethod
    def to_dict(query_result):
        return {  static.keys[&#39;STATISTICS&#39;][&#39;RETURN&#39;] : query_result[0][0] if query_result[0][0] != &#39;empty&#39; else None, 
                  static.keys[&#39;STATISTICS&#39;][&#39;VOLATILITY&#39;] : query_result[0][1] if query_result[0][1] != &#39;empty&#39; else None,
                  static.keys[&#39;STATISTICS&#39;][&#39;SHARPE&#39;] : query_result[0][2] if query_result[0][2] != &#39;empty&#39; else None,
                  static.keys[&#39;STATISTICS&#39;][&#39;BETA&#39;] : query_result[0][3] if query_result[0][3] != &#39;empty&#39; else None,
                  static.keys[&#39;STATISTICS&#39;][&#39;EQUITY&#39;] : query_result[0][4] if query_result[0][4] != &#39;empty&#39; else None }

    def save_or_update_row(self, ticker, start_date, end_date, annual_return=None, annual_volatility=None, sharpe_ratio=None, asset_beta=None, equity_cost=None, method=settings.ESTIMATION_METHOD):
        formatter = { &#39;ticker&#39;: ticker, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;method&#39;: method}
        
        if annual_return is not None:
            logger.verbose(f&#39;Updating SQLite cache... \n\t{ProfileCache.update_return_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :annual_return={annual_return}&#39;)
            formatter[&#39;annual_return&#39;] = annual_return
            self.execute_transaction(transaction=ProfileCache.update_return_transaction, formatter=formatter)
        if annual_volatility is not None:
            logger.verbose(f&#39;Updating SQLite cache... \n\t{ProfileCache.update_vol_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :annual_volatility={annual_volatility}&#39;)
            formatter[&#39;annual_volatility&#39;] = annual_volatility
            self.execute_transaction(transaction=ProfileCache.update_vol_transaction, formatter=formatter)        
        if sharpe_ratio is not None:
            logger.verbose(f&#39;Updating SQLite cache... \n\t{ProfileCache.update_sharpe_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :sharpe_ratio={sharpe_ratio}&#39;)
            formatter[&#39;sharpe_ratio&#39;] = sharpe_ratio
            self.execute_transaction(transaction=ProfileCache.update_sharpe_transaction, formatter=formatter)
        if asset_beta is not None:
            logger.verbose(f&#39;Updating SQLite cache \n\t{ProfileCache.update_beta_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :asset_beta={asset_beta}&#39;)
            formatter[&#39;asset_beta&#39;] = asset_beta
            self.execute_transaction(transaction=ProfileCache.update_beta_transaction, formatter=formatter)
        if equity_cost is not None:
            logger.verbose(f&#39;Updating SQLite cache \n\t{ProfileCache.update_return_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :equity_cost={equity_cost}&#39;)
            formatter[&#39;equity_cost&#39;] = equity_cost
            self.execute_transaction(transaction=ProfileCache.update_equity_tranasction, formatter=formatter)

    def filter_profile_cache(self, ticker, start_date, end_date, method = settings.ESTIMATION_METHOD):
        logger.debug(f&#39;Querying SQLite cache: \n\t{ProfileCache.profile_query}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}&#39;) 
        formatter = { &#39;ticker&#39;: ticker, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;method&#39;: method }
        result = self.execute_query(query=ProfileCache.profile_query, formatter=formatter)

        if len(result)&gt;0:
            logger.debug(f&#39;{ticker} profile found in cache&#39;)
            return self.to_dict(result)
        logger.debug(f&#39;No results found for {ticker} profile in the cache&#39;)
        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrilla.cache.Cache" href="#scrilla.cache.Cache">Cache</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrilla.cache.ProfileCache.beta_query"><code class="name">var <span class="ident">beta_query</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.create_table_transaction"><code class="name">var <span class="ident">create_table_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.equity_query"><code class="name">var <span class="ident">equity_query</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.identity_query"><code class="name">var <span class="ident">identity_query</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.profile_query"><code class="name">var <span class="ident">profile_query</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.query_filter"><code class="name">var <span class="ident">query_filter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.return_query"><code class="name">var <span class="ident">return_query</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.sharpe_query"><code class="name">var <span class="ident">sharpe_query</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.update_beta_transaction"><code class="name">var <span class="ident">update_beta_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.update_equity_tranasction"><code class="name">var <span class="ident">update_equity_tranasction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.update_return_transaction"><code class="name">var <span class="ident">update_return_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.update_sharpe_transaction"><code class="name">var <span class="ident">update_sharpe_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.update_vol_transaction"><code class="name">var <span class="ident">update_vol_transaction</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.value_args"><code class="name">var <span class="ident">value_args</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrilla.cache.ProfileCache.vol_query"><code class="name">var <span class="ident">vol_query</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="scrilla.cache.ProfileCache.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>query_result)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_dict(query_result):
    return {  static.keys[&#39;STATISTICS&#39;][&#39;RETURN&#39;] : query_result[0][0] if query_result[0][0] != &#39;empty&#39; else None, 
              static.keys[&#39;STATISTICS&#39;][&#39;VOLATILITY&#39;] : query_result[0][1] if query_result[0][1] != &#39;empty&#39; else None,
              static.keys[&#39;STATISTICS&#39;][&#39;SHARPE&#39;] : query_result[0][2] if query_result[0][2] != &#39;empty&#39; else None,
              static.keys[&#39;STATISTICS&#39;][&#39;BETA&#39;] : query_result[0][3] if query_result[0][3] != &#39;empty&#39; else None,
              static.keys[&#39;STATISTICS&#39;][&#39;EQUITY&#39;] : query_result[0][4] if query_result[0][4] != &#39;empty&#39; else None }</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrilla.cache.ProfileCache.filter_profile_cache"><code class="name flex">
<span>def <span class="ident">filter_profile_cache</span></span>(<span>self, ticker, start_date, end_date, method='moments')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_profile_cache(self, ticker, start_date, end_date, method = settings.ESTIMATION_METHOD):
    logger.debug(f&#39;Querying SQLite cache: \n\t{ProfileCache.profile_query}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}&#39;) 
    formatter = { &#39;ticker&#39;: ticker, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;method&#39;: method }
    result = self.execute_query(query=ProfileCache.profile_query, formatter=formatter)

    if len(result)&gt;0:
        logger.debug(f&#39;{ticker} profile found in cache&#39;)
        return self.to_dict(result)
    logger.debug(f&#39;No results found for {ticker} profile in the cache&#39;)
    return None</code></pre>
</details>
</dd>
<dt id="scrilla.cache.ProfileCache.save_or_update_row"><code class="name flex">
<span>def <span class="ident">save_or_update_row</span></span>(<span>self, ticker, start_date, end_date, annual_return=None, annual_volatility=None, sharpe_ratio=None, asset_beta=None, equity_cost=None, method='moments')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_or_update_row(self, ticker, start_date, end_date, annual_return=None, annual_volatility=None, sharpe_ratio=None, asset_beta=None, equity_cost=None, method=settings.ESTIMATION_METHOD):
    formatter = { &#39;ticker&#39;: ticker, &#39;start_date&#39;: start_date, &#39;end_date&#39;: end_date, &#39;method&#39;: method}
    
    if annual_return is not None:
        logger.verbose(f&#39;Updating SQLite cache... \n\t{ProfileCache.update_return_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :annual_return={annual_return}&#39;)
        formatter[&#39;annual_return&#39;] = annual_return
        self.execute_transaction(transaction=ProfileCache.update_return_transaction, formatter=formatter)
    if annual_volatility is not None:
        logger.verbose(f&#39;Updating SQLite cache... \n\t{ProfileCache.update_vol_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :annual_volatility={annual_volatility}&#39;)
        formatter[&#39;annual_volatility&#39;] = annual_volatility
        self.execute_transaction(transaction=ProfileCache.update_vol_transaction, formatter=formatter)        
    if sharpe_ratio is not None:
        logger.verbose(f&#39;Updating SQLite cache... \n\t{ProfileCache.update_sharpe_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :sharpe_ratio={sharpe_ratio}&#39;)
        formatter[&#39;sharpe_ratio&#39;] = sharpe_ratio
        self.execute_transaction(transaction=ProfileCache.update_sharpe_transaction, formatter=formatter)
    if asset_beta is not None:
        logger.verbose(f&#39;Updating SQLite cache \n\t{ProfileCache.update_beta_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :asset_beta={asset_beta}&#39;)
        formatter[&#39;asset_beta&#39;] = asset_beta
        self.execute_transaction(transaction=ProfileCache.update_beta_transaction, formatter=formatter)
    if equity_cost is not None:
        logger.verbose(f&#39;Updating SQLite cache \n\t{ProfileCache.update_return_transaction}\n\t\t with :ticker={ticker}, :start_date={start_date}, :end_date={end_date}, :equity_cost={equity_cost}&#39;)
        formatter[&#39;equity_cost&#39;] = equity_cost
        self.execute_transaction(transaction=ProfileCache.update_equity_tranasction, formatter=formatter)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrilla" href="index.html">scrilla</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrilla.cache.Cache" href="#scrilla.cache.Cache">Cache</a></code></h4>
<ul class="">
<li><code><a title="scrilla.cache.Cache.execute_query" href="#scrilla.cache.Cache.execute_query">execute_query</a></code></li>
<li><code><a title="scrilla.cache.Cache.execute_transaction" href="#scrilla.cache.Cache.execute_transaction">execute_transaction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrilla.cache.CorrelationCache" href="#scrilla.cache.CorrelationCache">CorrelationCache</a></code></h4>
<ul class="">
<li><code><a title="scrilla.cache.CorrelationCache.correlation_query" href="#scrilla.cache.CorrelationCache.correlation_query">correlation_query</a></code></li>
<li><code><a title="scrilla.cache.CorrelationCache.create_table_transaction" href="#scrilla.cache.CorrelationCache.create_table_transaction">create_table_transaction</a></code></li>
<li><code><a title="scrilla.cache.CorrelationCache.filter_correlation_cache" href="#scrilla.cache.CorrelationCache.filter_correlation_cache">filter_correlation_cache</a></code></li>
<li><code><a title="scrilla.cache.CorrelationCache.insert_row_transaction" href="#scrilla.cache.CorrelationCache.insert_row_transaction">insert_row_transaction</a></code></li>
<li><code><a title="scrilla.cache.CorrelationCache.save_row" href="#scrilla.cache.CorrelationCache.save_row">save_row</a></code></li>
<li><code><a title="scrilla.cache.CorrelationCache.to_dict" href="#scrilla.cache.CorrelationCache.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrilla.cache.InterestCache" href="#scrilla.cache.InterestCache">InterestCache</a></code></h4>
<ul class="">
<li><code><a title="scrilla.cache.InterestCache.create_table_transaction" href="#scrilla.cache.InterestCache.create_table_transaction">create_table_transaction</a></code></li>
<li><code><a title="scrilla.cache.InterestCache.filter_interest_cache" href="#scrilla.cache.InterestCache.filter_interest_cache">filter_interest_cache</a></code></li>
<li><code><a title="scrilla.cache.InterestCache.insert_row_transaction" href="#scrilla.cache.InterestCache.insert_row_transaction">insert_row_transaction</a></code></li>
<li><code><a title="scrilla.cache.InterestCache.save_row" href="#scrilla.cache.InterestCache.save_row">save_row</a></code></li>
<li><code><a title="scrilla.cache.InterestCache.stat_query" href="#scrilla.cache.InterestCache.stat_query">stat_query</a></code></li>
<li><code><a title="scrilla.cache.InterestCache.to_dict" href="#scrilla.cache.InterestCache.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrilla.cache.PriceCache" href="#scrilla.cache.PriceCache">PriceCache</a></code></h4>
<ul class="">
<li><code><a title="scrilla.cache.PriceCache.create_table_transaction" href="#scrilla.cache.PriceCache.create_table_transaction">create_table_transaction</a></code></li>
<li><code><a title="scrilla.cache.PriceCache.filter_price_cache" href="#scrilla.cache.PriceCache.filter_price_cache">filter_price_cache</a></code></li>
<li><code><a title="scrilla.cache.PriceCache.insert_row_transaction" href="#scrilla.cache.PriceCache.insert_row_transaction">insert_row_transaction</a></code></li>
<li><code><a title="scrilla.cache.PriceCache.price_query" href="#scrilla.cache.PriceCache.price_query">price_query</a></code></li>
<li><code><a title="scrilla.cache.PriceCache.save_row" href="#scrilla.cache.PriceCache.save_row">save_row</a></code></li>
<li><code><a title="scrilla.cache.PriceCache.to_dict" href="#scrilla.cache.PriceCache.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrilla.cache.ProfileCache" href="#scrilla.cache.ProfileCache">ProfileCache</a></code></h4>
<ul class="">
<li><code><a title="scrilla.cache.ProfileCache.beta_query" href="#scrilla.cache.ProfileCache.beta_query">beta_query</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.create_table_transaction" href="#scrilla.cache.ProfileCache.create_table_transaction">create_table_transaction</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.equity_query" href="#scrilla.cache.ProfileCache.equity_query">equity_query</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.filter_profile_cache" href="#scrilla.cache.ProfileCache.filter_profile_cache">filter_profile_cache</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.identity_query" href="#scrilla.cache.ProfileCache.identity_query">identity_query</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.profile_query" href="#scrilla.cache.ProfileCache.profile_query">profile_query</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.query_filter" href="#scrilla.cache.ProfileCache.query_filter">query_filter</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.return_query" href="#scrilla.cache.ProfileCache.return_query">return_query</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.save_or_update_row" href="#scrilla.cache.ProfileCache.save_or_update_row">save_or_update_row</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.sharpe_query" href="#scrilla.cache.ProfileCache.sharpe_query">sharpe_query</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.to_dict" href="#scrilla.cache.ProfileCache.to_dict">to_dict</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.update_beta_transaction" href="#scrilla.cache.ProfileCache.update_beta_transaction">update_beta_transaction</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.update_equity_tranasction" href="#scrilla.cache.ProfileCache.update_equity_tranasction">update_equity_tranasction</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.update_return_transaction" href="#scrilla.cache.ProfileCache.update_return_transaction">update_return_transaction</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.update_sharpe_transaction" href="#scrilla.cache.ProfileCache.update_sharpe_transaction">update_sharpe_transaction</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.update_vol_transaction" href="#scrilla.cache.ProfileCache.update_vol_transaction">update_vol_transaction</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.value_args" href="#scrilla.cache.ProfileCache.value_args">value_args</a></code></li>
<li><code><a title="scrilla.cache.ProfileCache.vol_query" href="#scrilla.cache.ProfileCache.vol_query">vol_query</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>